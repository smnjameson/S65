/**
* .macro ImportSpriteset
*
* Helper function to preload the sprites _chars file generated by png65 into a given address
* and load the _meta file <br>
* S65 provides space for up to 16 sprite set imports at any one time<br>
* When loading using these imports you only need the first part of the path and file name. eg<br><br>
* Asset_ImportSpriteset("player","assets/bin/sprites1", $8000)<br><br>
* Will load both the "assets/bin/sprites1_chars.bin" and the "assets/bin/sprites1_meta.s" files.
* NCM or FCM is determined from the metafile<br><br>
* NOTE: MUST be called before the Layer_InitScreen
* @namespace Asset
*
* @param {string} name The name to refer to this spriteset 
* @param {string} charpath The path to the _chars and _meta file generated by png65
* @param {word} address The address to laod the sprites char data into
*/
.macro Asset_ImportSpriteset (name, path, address) {
		.if(address / $40 != floor(address/$40)) {
			.eval address = (floor(address/$40) + 1) * $40 
			S65_Trace("Aligning sprites for "+name+" to $40 boundary")
		}
		//Add an entry to the buildtime spriteset list
        .eval Asset_SpriteList.add( Asset_Spriteset(
        	Asset_SpriteList.size(), 	//id
        	name,
            address,
            $0000,						//metAddress
            List(),						//meta
            List(),						//palette
            List()						//indices
        ))

        
        .var PC = *
        * = address "Spriteset importing"
    		.import binary path+"_chars.bin"

    		//Create meta data list from binary
    		.var spriteSheet = Asset_SpriteList.get(Asset_SpriteList.size() - 1)
    		.var dataBin = LoadBinary(path+"_meta.bin")
    		.var data = spriteSheet.meta
    		.for(var i=0; i<dataBin.getSize(); i++) .eval data.add(dataBin.get(i))

    		.var numSprites = data.get($02) + data.get($03) * $100
    		S65_Trace(""+name+" spriteset of "+numSprites+" sprites, data at $"+toHexString(address))


			//adjust char indices to new offset
			.var offset = spriteSheet.address / $40
			.for(var i=0; i<numSprites; i++) {
				.var indexLo = $20 + numSprites * 0 + i
				.var indexHi = $20 + numSprites * 1 + i
				.eval data.set(indexLo, (data.get(indexLo) + <offset))
				.eval data.set(indexHi, (data.get(indexHi) + >offset))
				.eval spriteSheet.indices.add(data.get(indexLo) + data.get(indexHi) * $100)
			}

    		.var paletteBin = LoadBinary(path+"_palette.bin")
    		.eval spriteSheet.palette = paletteBin

    		S65_Trace(""+name+" spriteset metadata at $"+toHexString(*))
    		Sprite_GenerateMetaData()

    		.eval S65_LastImportPtr = *
        * = PC "Spriteset import"
}


/**
* .macro ImportCharset
*
* Helper function to preload the _chars file generated by png65 into a given address
* and load the _ncm file <br>
* When loading using these imports you only need the first part of the path and file name. eg<br><br>
* Asset_ImportCharset("map","assets/bin/tileset1", $8000)<br><br>
* Will load both the "assets/bin/tileset1_chars.bin" and the "assets/bin/tileset1_ncm.s" files.
* NOTE: MUST be called before the Layer_InitScreen
* @namespace Asset
*
* @param {string} name The name to refer to this charset 
* @param {string} charpath The path to the _chars and _ncm file generated by png65
* @param {word} address The address to laod the char data into
*/
.macro Asset_ImportCharset (name, path, address) {
		.if(address / $40 != floor(address/$40)) {
			.eval address = (floor(address/$40) + 1) * $40 
			S65_Trace("Aligning chars for "+name+" to $40 boundary")
		}

		//Add an entry to the buildtime spriteset list
		//{ id, name, address, colorAddress, palette, colors }
        .eval Asset_CharList.add( Asset_Charset(
        	Asset_CharList.size(), 	//id

        	name,
            address,
            $0000,						//colorAddress
            List(),						//palette
            List(),						//colors
            List()						//Indices
        ))       

        .var PC = *
        * = address "Charset importing"
    		.import binary path+"_chars.bin"

    		.var charSet = Asset_CharList.get(Asset_CharList.size() - 1)

    		.for(var i=0; i< (*-address)/$40; i++) {
    			.eval charSet.indices.add(address/$40 + i)
    		}	

    		.var paletteBin = LoadBinary(path+"_palette.bin")
    		.eval charSet.palette = paletteBin

    		.var ncmBin = LoadBinary(path+"_ncm.bin")
    		.eval charSet.colors = ncmBin
    		.if(ncmBin.getSize() > 0) {
    			.eval charSet.colorAddress = *
    			.fill ncmBin.getSize(), ncmBin.get(i)
    		}

    		.eval S65_LastImportPtr = *
        * = PC "Charset import"
}


/**
* .macro ImportSpritesetPalette
*
* Data generation macro that imports the full 256 color palette for
* the given spriteset name. The spriteset must be imported already 
* otherwise this will fail.
* 
* @namespace Asset
*
* @param {string} name The name of the spriteset to import the palette for
*/
.macro Asset_ImportSpritesetPalette( name ) {
	.var palette = Asset_SpriteList.get(Asset_GetSpriteset(name).get("id")).get("palette")

	.fill palette.getSize(), palette.get(i)
}


/**
* .macro ImportCharsetPalette
*
* Data generation macro that imports the full 256 color palette for
* the given charset name. The charset must be imported already 
* otherwise this will fail.
* 
* @namespace Asset
*
* @param {string} name The name of the charset to import the palette for
*/
.macro Asset_ImportCharsetPalette( name ) {
	.var palette = Asset_CharList.get(Asset_GetCharset(name).get("id")).get("palette")
	.fill palette.getSize(), palette.get(i)
}