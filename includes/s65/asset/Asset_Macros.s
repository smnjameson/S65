
/**
* .macro Preload
* Internal macro used to preload assets when imports have been done at or above $f000.
* Before initialisation any preloaded assets get loaded here
* @namespace Asset
*/
.macro Asset_Preload() {
	.if(Asset_PreloaderList.size() > 0) {
		lda #$ff 
		sta $d020 
		lda #$6b 
		sta $d011 

		.for(var i=0; i<Asset_PreloaderList.size(); i++) {
			.var asset = Asset_PreloaderList.get(i)
			SDCard_LoadToChipRam  asset.get("addr") : asset.get("filename")
			.print("preload "+asset.get("name")+" to $"+toHexString(asset.get("addr")) +"  fn: $"+toHexString(asset.get("filename")) )
		}

		lda #$1b 
		sta $d011 		
	}
}
_Asset_Preload: {
	Start: {
		.import binary "splash/bin/bin/splashstart.bin"
	}
	End: {
		.import binary "splash/bin/bin/splashend.bin"
	}	
	Splash:
		.encoding "ascii"
		.text "SPL"
		.byte $00
		.encoding "screencode_mixed"
}
/**
* .macro ImportSpriteset
*
* Helper function to preload the sprites _chars file generated by png65 into a given address
* and load the _meta file <br>
* S65 provides space for up to 16 sprite set imports at any one time<br>
* When loading using these imports you only need the first part of the path and file name. eg<br><br>
* Asset_ImportSpriteset("player","assets/bin/sprites1", $8000)<br><br>
* Will load both the "assets/bin/sprites1_chars.bin" and the "assets/bin/sprites1_meta.s" files.
* NCM or FCM is determined from the metafile<br><br>
* NOTE: MUST be called before the Layer_InitScreen
* @namespace Asset
*
* @param {string} name The name to refer to this spriteset 
* @param {string} charpath The path to the _chars and _meta file generated by png65
* @param {word} address The address to laod the sprites char data into
*/
.macro Asset_ImportSpriteset (name, path, address) {
		.if(address / $40 != floor(address/$40)) {
			.eval address = (floor(address/$40) + 1) * $40 
			S65_Trace("Aligning sprites for "+name+" to $40 boundary")
		}

		//preload?
		.var preload = false
		.if(address >= S65_HIGHEST_LOAD) {
			.var name = "P"+Asset_PreloaderList.size()
			Asset_PreloaderFetchSegment(Asset_PreloaderList.size())
				.eval Asset_PreloaderList.add(Hashtable().put(
					"name", name,
					"addr", address,
					"filename", Asset_PreloaderFilenamePointer 
				))
				.import binary path+"_chars.bin"
				.print("Adding "+name+" spriteset asssets to the preloader")
			.segment S65Code

			.segment PreloadFilenames
			.encoding "ascii"
				.text name
				.byte $00,$01
				.eval Asset_PreloaderFilenamePointer = *
			.encoding "screencode_mixed"
			.segment S65Code

			.eval preload = true
		}

		//Add an entry to the buildtime spriteset list
        .eval Asset_SpriteList.add( Asset_Spriteset(
        	Asset_SpriteList.size(), 	//id
        	name,
            address,
            $0000,						//metAddress
            List(),						//meta
            List(),						//palette
            List()						//indices
        ))

        
        .var PC = *
        
    		.if(!preload) {
    			* = address "Spriteset importing"
    			.import binary path+"_chars.bin"
    		}

    		//Create meta data list from binary
    		.var spriteSheet = Asset_SpriteList.get(Asset_SpriteList.size() - 1)
    		.var dataBin = LoadBinary(path+"_meta.bin")
    		.var data = spriteSheet.meta
    		.for(var i=0; i<dataBin.getSize(); i++) .eval data.add(dataBin.get(i))

    		.var numSprites = data.get($02) + data.get($03) * $100
    		S65_Trace(""+name+" spriteset of "+numSprites+" sprites, data at $"+toHexString(address))


			//adjust char indices to new offset
			.var offset = spriteSheet.address / $40
			.for(var i=0; i<numSprites; i++) {
				.var indexLo = $20 + numSprites * 0 + i
				.var indexHi = $20 + numSprites * 1 + i
				.eval data.set(indexLo, (data.get(indexLo) + <offset))
				.eval data.set(indexHi, (data.get(indexHi) + >offset))
				.eval spriteSheet.indices.add(data.get(indexLo) + data.get(indexHi) * $100)
			}

    		.var paletteBin = LoadBinary(path+"_palette.bin")
    		.eval spriteSheet.palette = paletteBin

    		S65_Trace(""+name+" spriteset metadata at $"+toHexString(*))
    		Sprite_GenerateMetaData()

        .if(!preload) {
        	.eval S65_LastImportPtr = *
        	* = PC "Charset import"
        } else {
        	.var bin = LoadBinary(path+"_chars.bin")
        	.eval S65_LastImportPtr = address + bin.getSize()
        }
}


/**
* .macro ImportCharset
*
* Helper function to preload the _chars file generated by png65 into a given address
* and load the _ncm file <br>
* When loading using these imports you only need the first part of the path and file name. eg<br><br>
* Asset_ImportCharset("map","assets/bin/tileset1", $8000)<br><br>
* Will load both the "assets/bin/tileset1_chars.bin" and the "assets/bin/tileset1_ncm.s" files.
* NOTE: MUST be called before the Layer_InitScreen
* @namespace Asset
*
* @param {string} name The name to refer to this charset 
* @param {string} charpath The path to the _chars and _ncm file generated by png65
* @param {word} address The address to laod the char data into
*/
.macro Asset_ImportCharset (name, path, address) {
		.if(address / $40 != floor(address/$40)) {
			.eval address = (floor(address/$40) + 1) * $40 
			S65_Trace("Aligning chars for "+name+" to $40 boundary")
		}
		

		//Add an entry to the buildtime spriteset list
		//{ id, name, address, colorAddress, palette, colors }
        .eval Asset_CharList.add( Asset_Charset(
        	Asset_CharList.size(), 	//id
        	name,
            address,
            $0000,						//colorAddress
            List(),						//palette
            List(),						//colors
            List()						//Indices
        ))   


		//preload?
		.var preload = false
		.if(address >= S65_HIGHEST_LOAD) {
			.var name = "P"+Asset_PreloaderList.size()
			Asset_PreloaderFetchSegment(Asset_PreloaderList.size())
				.eval Asset_PreloaderList.add(Hashtable().put(
					"name", name,
					"addr", address,
					"filename", Asset_PreloaderFilenamePointer 
				))
				.import binary path+"_chars.bin"
				.print("Adding "+name+" spriteset asssets to the preloader")
			.segment S65Code

			.segment PreloadFilenames
			.encoding "ascii"
				.text name
				.byte $00
				.eval Asset_PreloaderFilenamePointer = *
			.encoding "screencode_mixed"
			.segment S65Code

			.eval preload = true
		}


    

        .var PC = *  
         .var charSet = Asset_CharList.get(Asset_CharList.size() - 1)

		.if(!preload) {
			* = address "Charset importing"
			.import binary path+"_chars.bin"
			.for(var i=0; i< (*-address)/$40; i++) {
    			.eval charSet.indices.add(address/$40 + i)
    		}		
		} else {
			.var bin = LoadBinary(path+"_chars.bin")
			.for(var i=0; i< [bin.getSize() / $40]; i++) {
    			.eval charSet.indices.add(address/$40 + i)
    		}	
		}


           


    		.var paletteBin = LoadBinary(path+"_palette.bin")
    		.eval charSet.palette = paletteBin

    		.var ncmBin = LoadBinary(path+"_ncm.bin")
    		.eval charSet.colors = ncmBin
    		.if(ncmBin.getSize() > 0) {
    			.eval charSet.colorAddress = *
    			.fill ncmBin.getSize(), ncmBin.get(i)
    		}

    		
        .if(!preload) {
        	.eval S65_LastImportPtr = *
        	* = PC "Charset import"
        } else {
        	.var bin = LoadBinary(path+"_chars.bin")
        	.eval S65_LastImportPtr = address + bin.getSize()
        }
}


/**
* .macro ImportSpritesetPalette
*
* Data generation macro that imports the full 256 color palette for
* the given spriteset name. The spriteset must be imported already 
* otherwise this will fail.
* 
* @namespace Asset
*
* @param {string} name The name of the spriteset to import the palette for
*/
.macro Asset_ImportSpritesetPalette( name ) {
	.var palette = Asset_SpriteList.get(Asset_GetSpriteset(name).get("id")).get("palette")

	.fill palette.getSize(), palette.get(i)
}


/**
* .macro ImportCharsetPalette
*
* Data generation macro that imports the full 256 color palette for
* the given charset name. The charset must be imported already 
* otherwise this will fail.
* 
* @namespace Asset
*
* @param {string} name The name of the charset to import the palette for
*/
.macro Asset_ImportCharsetPalette( name ) {
	.var palette = Asset_CharList.get(Asset_GetCharset(name).get("id")).get("palette")
	.fill palette.getSize(), palette.get(i)
}