/**
* .macro ImportSprites 
*
* Helper function to preload the sprites _chars file generated by png65 into a given address
* and load the _meta file to create the sprite to char index values for
* use in ...<br> 
* S65 provides space for up to 16 sprite set imports at any one time<br>
* When loading using these imports you only need the first part of the path and file name. eg<br><br>
* S65_ImportSprites("player","assets/bin/sprites1", $8000)<br><br>
* Will load both the "assets/bin/sprites1_ncm.bin" (or _fcm) and the "assets/bin/sprites1_meta.s" files.
* NCM or FCM is determined from the metafile<br><br>
* NOTE: MUST be called before the Layer_InitScreen
* @namespace Asset
*
* @param {string} name The name to refer to this spriteset when using the Sprite_GetPointer function
* @param {string} charpath The path to the _chars and _meta file generated by png65
* @param {word} address The address to laod the sprites char data into
*/
.macro Asset_ImportSprites (name, path, address) {
		.if(address / $40 != floor(address/$40)) {
			.eval address = (floor(address/$40) + 1) * $40 
			S65_Trace("Aligning sprites for "+name+" to $40 boundary")
		}
		//Add an entry to the buildtime spriteset list
        .eval Sprite_SpriteList.add( Sprite_Spriteset(
        	Sprite_SpriteList.size(), 	//id
        	name,
            address,
            $0000,						//metAddress
            List(),						//meta
            List(),						//palette
            List()						//indices
        ))

        

        .var PC = *
        .var val ="Sprites"
        * = address
        	

    		.import binary path+"_chars.bin"

    		//Create meta data list from binary
    		.var spriteSheet = Sprite_SpriteList.get(Sprite_SpriteList.size() - 1)
    		.var dataBin = LoadBinary(path+"_meta.bin")
    		.var data = spriteSheet.meta
    		.for(var i=0; i<dataBin.getSize(); i++) .eval data.add(dataBin.get(i))

    		.var numSprites = data.get($02) + data.get($03) * $100
    		S65_Trace(""+name+" spriteset of "+numSprites+" sprites, data at $"+toHexString(address))


			//adjust char indices to new offset
			.var offset = spriteSheet.address / $40
			.for(var i=0; i<numSprites; i++) {
				.var indexLo = $20 + numSprites * 0 + i
				.var indexHi = $20 + numSprites * 1 + i
				.eval data.set(indexLo, (data.get(indexLo) + <offset))
				.eval data.set(indexHi, (data.get(indexHi) + >offset))
				.eval spriteSheet.indices.add(data.get(indexLo) + data.get(indexHi) * $100)
			}

    		.var paletteBin = LoadBinary(path+"_palette.bin")
    		.eval spriteSheet.palette = paletteBin

    		S65_Trace(""+name+" spriteset metadata at $"+toHexString(*))
    		Sprite_GenerateMetaData()

    		.eval S65_LastImportPtr = *
        * = PC
}


/**
* .macro ImportSpritePalette
*
* Data generation macro that imports the full 256 color palette for
* the given spriteset name. The spriteset must be imported already 
* otherwise this will fail.
* 
* @namespace Asset
*
* @param {string} name The name of the spriteset to import the palette for
*/
.macro Asset_ImportSpritePalette( name ) {
	.var palette = Sprite_SpriteList.get(Asset_GetSpriteset(name).get("id")).get("palette")

	.fill palette.getSize(), palette.get(i)
}
