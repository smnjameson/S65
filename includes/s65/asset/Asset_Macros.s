
/**
* .macro Preload
* Internal macro used to preload assets when imports have been done at or above $f000.
* Before initialisation any preloaded assets get loaded here
* @namespace Asset
*/
.macro Asset_Preload() {
	.if(Asset_PreloaderList.size() > 0) {
		System_HideScreen

		.for(var i=0; i<Asset_PreloaderList.size(); i++) {
			.var asset = Asset_PreloaderList.get(i)
			SDCard_LoadToChipRam  asset.get("addr") : asset.get("filename")
			S65_Trace("preload "+asset.get("name")+" to $"+toHexString(asset.get("addr")) +"  fn: $"+toHexString(asset.get("filename")) )
		}

		System_ShowScreen		
	}
}

/**
* .macro ImportSpriteset
*
* Helper function to preload the sprites _chars file generated by png65 into a given address
* and load the _meta file <br>
* S65 provides space for up to 16 sprite set imports at any one time<br>
* When loading using these imports you only need the first part of the path and file name. eg<br><br>
* Asset_ImportSpriteset("player","assets/bin/sprites1", $8000)<br><br>
* Will load both the "assets/bin/sprites1_chars.bin" and the "assets/bin/sprites1_meta.s" files.
* NCM or FCM is determined from the metafile<br><br>
* NOTE: MUST be called before the Layer_InitScreen
* @namespace Asset
*
* @param {string} name The name to refer to this spriteset 
* @param {string} charpath The path to the _chars and _meta file generated by png65
* @param {word} address The address to laod the sprites char data into
*/
.macro Asset_ImportSpriteset (name, path, address) {
		.if(address / $40 != floor(address/$40)) {
			.eval address = (floor(address/$40) + 1) * $40 
			S65_Trace("Aligning sprites for "+name+" to $40 boundary")
		}

		//preload?
		.var preload = false
		.if(address >= S65_HIGHEST_LOAD) {
			.var name = "P"+Asset_PreloaderList.size()
			Asset_PreloaderFetchSegment(Asset_PreloaderList.size())
				.eval Asset_PreloaderList.add(Hashtable().put(
					"name", name,
					"addr", address,
					"filename", Asset_PreloaderFilenamePointer 
				))
				.import binary path+"_chars.bin"
				S65_Trace("Adding "+name+" spriteset asssets to the preloader @ $"+toHexString(address))
			.segment S65Code

			.segment PreloadFilenames
			.encoding "ascii"
				.text name
				.byte $00
				.eval Asset_PreloaderFilenamePointer = *
			.encoding "screencode_mixed"
			.segment S65Code

			.eval preload = true
		}

		//Add an entry to the buildtime spriteset list
        .eval Asset_SpriteList.add( Asset_Spriteset(
        	Asset_SpriteList.size(), 	//id
        	name,
            address,
            $0000,						//metAddress
            List(),						//meta
            List(),						//palette
            List()						//indices
        ))

        
        .var PC = *
        
    		.if(!preload) {
    			* = address "Spriteset importing"
    			.import binary path+"_chars.bin"
    		}

    		//Create meta data list from binary
    		.var spriteSheet = Asset_SpriteList.get(Asset_SpriteList.size() - 1)
    		.var dataBin = LoadBinary(path+"_meta.bin")
    		.var data = spriteSheet.meta
    		.for(var i=0; i<dataBin.getSize(); i++) .eval data.add(dataBin.uget(i))

    		.var numSprites = data.get($02) + data.get($03) * $100
    		S65_Trace(""+name+" spriteset of "+numSprites+" sprites, data at $"+toHexString(address))


			//adjust char indices to new offset
			.var offset = spriteSheet.address / $40
			.for(var i=0; i<numSprites; i++) {
				.var indexLo = $20 + numSprites * 0 + i
				.var indexHi = $20 + numSprites * 1 + i
				.eval data.set(indexLo, (data.get(indexLo) + <offset))
				.eval data.set(indexHi, (data.get(indexHi) + >offset))
				.eval spriteSheet.indices.add(data.get(indexLo) + data.get(indexHi) * $100)
			}

    		.var paletteBin = LoadBinary(path+"_palette.bin")
    		.eval spriteSheet.palette = paletteBin

    		S65_Trace(""+name+" spriteset metadata at $"+toHexString(*))
    		Sprite_GenerateMetaData()

        .if(!preload) {
        	.eval S65_LastImportPtr = *
        	* = PC "Charset import"
        } else {
        	.var bin = LoadBinary(path+"_chars.bin")
        	.eval S65_LastImportPtr = address + bin.getSize()
        }
}


/**
* .macro ImportCharset
*
* Helper function to preload the _chars file generated by png65 into a given address
* and load the _ncm file <br>
* When loading using these imports you only need the first part of the path and file name. eg<br><br>
* Asset_ImportCharset("map","assets/bin/tileset1", $8000)<br><br>
* Will load both the "assets/bin/tileset1_chars.bin" and the "assets/bin/tileset1_ncm.s" files.
* NOTE: MUST be called before the Layer_InitScreen
* @namespace Asset
*
* @param {string} name The name to refer to this charset 
* @param {string} path The path to the _chars and _ncm file generated by png65
* @param {word} address The address to laod the char data into
*/
.macro Asset_ImportCharset (name, path, address) {
		.if(address / $40 != floor(address/$40)) {
			.eval address = (floor(address/$40) + 1) * $40 
			S65_Trace("Aligning chars for "+name+" to $40 boundary")
		}
		

		//Add an entry to the buildtime spriteset list
		//{ id, name, address, colorAddress, palette, colors }
        .eval Asset_CharList.add( Asset_Charset(
        	Asset_CharList.size(), 	//id
        	name,
            address,
            $0000,						//colorAddress
            List(),						//palette
            List(),						//colors
            List()						//Indices
        ))   


		//preload?
		.var preload = false
		.if(address >= S65_HIGHEST_LOAD) {
			.var name = "P"+Asset_PreloaderList.size()
			Asset_PreloaderFetchSegment(Asset_PreloaderList.size())
				.eval Asset_PreloaderList.add(Hashtable().put(
					"name", name,
					"addr", address,
					"filename", Asset_PreloaderFilenamePointer 
				))
				.import binary path+"_chars.bin"
				S65_Trace("Adding "+name+" charset asssets to the preloader @ $"+toHexString(address))
			.segment S65Code

			.segment PreloadFilenames
			.encoding "ascii"
				.text name
				.byte $00
				.eval Asset_PreloaderFilenamePointer = *
			.encoding "screencode_mixed"
			.segment S65Code

			.eval preload = true
		}


   		

        .var PC = *  
         .var charSet = Asset_CharList.get(Asset_CharList.size() - 1)

		.if(!preload) {
			* = address "Charset importing"
			.import binary path+"_chars.bin"
			.for(var i=0; i< (*-address)/$40; i++) {
    			.eval charSet.indices.add(address/$40 + i)
    		}		
		} else {
			.var bin = LoadBinary(path+"_chars.bin")
			.for(var i=0; i< [bin.getSize() / $40]; i++) {
    			.eval charSet.indices.add(address/$40 + i)
    		}	
		}


           


    		.var paletteBin = LoadBinary(path+"_palette.bin")
    		.eval charSet.palette = paletteBin

    		.var ncmBin = LoadBinary(path+"_ncm.bin")
    		.eval charSet.colors = List()
    		.if(ncmBin.getSize() > 0) {
    			.eval charSet.colorAddress = *
    			// .fill ncmBin.getSize(), ncmBin.uget(i)
    			.for(var i=0; i<ncmBin.getSize(); i++) {
    				.byte ncmBin.uget(i)
    				.eval charSet.colors.add(ncmBin.uget(i))
    			}
    		}

    		
        .if(!preload) {
        	.eval S65_LastImportPtr = *
        	* = PC "Charset import"
        } else {
        	.var bin = LoadBinary(path+"_chars.bin")
        	.eval S65_LastImportPtr = address + bin.getSize()
        }
}



/**
* .macro ImportTilemap
*
* Helper function to preload the _tiles and _map file generated by ldtk65 into a given address<br>
* When loading using these imports you only need the first part of the path and file name. eg<br><br>
* Asset_ImportTilemap("map","assets/bin/map", $8000)<br><br>
* Will load both the "assets/bin/map_tiles.bin" and the "assets/bin/map_map.s" files.
* NOTE: MUST be called before the Layer_InitScreen
* @namespace Asset
*
* @param {string} name The name to refer to this tilemap 
* @param {string} path The path to the _tiles and _map file generated by ldtk65
* @param {Asset_Charset} charset The charset to link to this tilemap
* @param {word} address The address to laod the data into
*/
.macro Asset_ImportTilemap(name, path, charset, address) {
		.var charbase = charset.indices.get(0)

        .eval Asset_TilemapList.add( Asset_Tilemap(
        	Asset_TilemapList.size(), 	//id
        	name,
            address,											//tilemapAddress
            $0000,												//tiledefAddress


            charset.colorAddress - charset.indices.get(0),		//coloraddress
            0,							//width
            0,							//height
            0,							//tilewidth
            0,							//tileheight
            List(),						//tilemap data
            List()						//tiles data
        ))   

        .var bin = LoadBinary(path+"_map.bin")
        .var tbin = LoadBinary(path+"_tiles.bin")


		//preload?
		.var preload = false
		.if(address >= S65_HIGHEST_LOAD) {
			.var name = "P"+Asset_PreloaderList.size()
			Asset_PreloaderFetchSegment(Asset_PreloaderList.size())
				.eval Asset_PreloaderList.add(Hashtable().put(
					"name", name,
					"addr", address,
					"filename", Asset_PreloaderFilenamePointer 
				))
				// .import binary path+"_map.bin"
				_Asset_ImportTilemap_StripTilemapHeader(path)

				// .import binary path+"_tiles.bin"
				_Asset_ImportTilemap_AddBaseToTiles(path, charbase, charset)
				S65_Trace("Adding "+name+" tilemap asssets to the preloader @ $"+toHexString(address))
				// S65_Trace("tile definitions @ $"+toHexString(address))
			.segment S65Code

			.segment PreloadFilenames
			.encoding "ascii"
				.text name
				.byte $00
				.eval Asset_PreloaderFilenamePointer = *
			.encoding "screencode_mixed"
			.segment S65Code
			.eval preload = true
		}

        .var PC = *  
        .var tilemap = Asset_TilemapList.get(Asset_TilemapList.size() - 1)

    	.eval tilemap.width = bin.uget(0) + bin.uget(1) * $100
		.eval tilemap.height = bin.uget(2) + bin.uget(3) * $100
		.eval tilemap.tilewidth = bin.uget(4)
		.eval tilemap.tileheight = bin.uget(5)

		.if(!preload) {
			* = address "Tilemap importing"
			// .import binary path+"_map.bin"
			_Asset_ImportTilemap_StripTilemapHeader(path)
			.eval tilemap.tiledefAddress = *
			// .import binary path+"_tiles.bin"
			_Asset_ImportTilemap_AddBaseToTiles(path, charbase, charset)
		} else {
			.eval tilemap.tiledefAddress = address + bin.getSize() - 6 //-6 for map header
		}
   		
		//Add tile definitons to struct

		.var size = tilemap.tilewidth * tilemap.tileheight
   		.for(var i=0; i<tbin.getSize(); i+=2 * size) {
   			.var tiledefs = List()
   			.for(var j=0; j<size; j++) {
	   			.var addr = [tbin.uget(i + j*2) + [tbin.uget(i  + j*2 + 1) * $100]] + charbase
	   			.eval tiledefs.add(addr)
   			}
   			.eval tilemap.tiles.add(tiledefs)
   		}


        .if(!preload) {
        	.eval S65_LastImportPtr = *
        	* = PC "Tilemap import"
        } else {
        	.eval S65_LastImportPtr = tilemap.tiledefAddress + tbin.getSize()
        }
}
.macro _Asset_ImportTilemap_StripTilemapHeader(path) {
		.var bin = LoadBinary(path+"_map.bin")	
		.fill bin.getSize()-6, bin.uget(i+6)
}
.macro _Asset_ImportTilemap_AddBaseToTiles(path, base, charset) {
		.var bin = LoadBinary(path+"_tiles.bin")
		.for(var i=0; i<bin.getSize(); i+=2) {
			.var addr = [bin.uget(i) + [bin.uget(i + 1) * $100]] + base
			.var tileNum = bin.uget(i) + $100 * bin.uget(i+1)

			.byte <addr, [>addr] + charset.colors.get(tileNum)
		}
}


/**
* .macro ImportSpritesetPalette
*
* Data generation macro that imports the full 256 color palette for
* the given spriteset name. The spriteset must be imported already 
* otherwise this will fail.
* 
* @namespace Asset
*
* @param {string} name The name of the spriteset to import the palette for
*/
.macro Asset_ImportSpritesetPalette( name ) {
	.var palette = Asset_SpriteList.get(Asset_GetSpriteset(name).get("id")).get("palette")

	.fill palette.getSize(), palette.get(i)
}


/**
* .macro ImportCharsetPalette
*
* Data generation macro that imports the full 256 color palette for
* the given charset name. The charset must be imported already 
* otherwise this will fail.
* 
* @namespace Asset
*
* @param {string} name The name of the charset to import the palette for
*/
.macro Asset_ImportCharsetPalette( name ) {
	.var palette = Asset_CharList.get(Asset_GetCharset(name).get("id")).get("palette")
	.fill palette.getSize(), palette.get(i)
}



/**
* .macro AddExternal
*
* Adds a new external asset file to the SDCard containing the binary data providewd. It can then be loaded
* later using the name provided
* 
* @namespace Asset
*
* @param {string} name The name to reference this file
* @param {binary} data The binary data, either from previous Asset_Imports (eg charset.palette) or from a kick ass LoadBinary()
*/
.macro Asset_AddExternal(name, data) {
		.var fname = "S"+Asset_ExternalAssetList.size()
		Asset_ExternalAssetFetchSegment(Asset_ExternalAssetList.size())
			.eval Asset_ExternalAssetList.add(Hashtable().put(
				"name", name,
				"filename", Asset_PreloaderFilenamePointer 
			))
			.fill data.getSize(), data.get(i)
			S65_Trace("Adding "+name+" external asssets to the SDCard")
		.segment S65Code

		.segment PreloadFilenames
		.encoding "ascii"
			.text fname
			.byte $00
			.eval Asset_PreloaderFilenamePointer = *
		.encoding "screencode_mixed"
		.segment S65Code
}

