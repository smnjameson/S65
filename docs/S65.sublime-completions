{
    "scope": "source.assembly.kickassembler",
    "completions": [
        {
            "trigger": "id",
            "annotation": "Asset_Spriteset",
            "kind": "snippet"
        },
        {
            "trigger": "name",
            "annotation": "Asset_Spriteset",
            "kind": "snippet"
        },
        {
            "trigger": "address",
            "annotation": "Asset_Spriteset",
            "kind": "snippet"
        },
        {
            "trigger": "metaAddress",
            "annotation": "Asset_Spriteset",
            "kind": "snippet"
        },
        {
            "trigger": "meta",
            "annotation": "Asset_Spriteset",
            "kind": "snippet"
        },
        {
            "trigger": "palette",
            "annotation": "Asset_Spriteset",
            "kind": "snippet"
        },
        {
            "trigger": "indices",
            "annotation": "Asset_Spriteset",
            "kind": "snippet"
        },
        {
            "trigger": "id",
            "annotation": "Asset_Charset",
            "kind": "snippet"
        },
        {
            "trigger": "name",
            "annotation": "Asset_Charset",
            "kind": "snippet"
        },
        {
            "trigger": "address",
            "annotation": "Asset_Charset",
            "kind": "snippet"
        },
        {
            "trigger": "colorAddress",
            "annotation": "Asset_Charset",
            "kind": "snippet"
        },
        {
            "trigger": "palette",
            "annotation": "Asset_Charset",
            "kind": "snippet"
        },
        {
            "trigger": "colors",
            "annotation": "Asset_Charset",
            "kind": "snippet"
        },
        {
            "trigger": "indices",
            "annotation": "Asset_Charset",
            "kind": "snippet"
        },
        {
            "trigger": "id",
            "annotation": "Asset_Tilemap",
            "kind": "snippet"
        },
        {
            "trigger": "name",
            "annotation": "Asset_Tilemap",
            "kind": "snippet"
        },
        {
            "trigger": "tilemapAddress",
            "annotation": "Asset_Tilemap",
            "kind": "snippet"
        },
        {
            "trigger": "tiledefAddress",
            "annotation": "Asset_Tilemap",
            "kind": "snippet"
        },
        {
            "trigger": "colorAddress",
            "annotation": "Asset_Tilemap",
            "kind": "snippet"
        },
        {
            "trigger": "width",
            "annotation": "Asset_Tilemap",
            "kind": "snippet"
        },
        {
            "trigger": "height",
            "annotation": "Asset_Tilemap",
            "kind": "snippet"
        },
        {
            "trigger": "tilewidth",
            "annotation": "Asset_Tilemap",
            "kind": "snippet"
        },
        {
            "trigger": "tileheight",
            "annotation": "Asset_Tilemap",
            "kind": "snippet"
        },
        {
            "trigger": "tilemap",
            "annotation": "Asset_Tilemap",
            "kind": "snippet"
        },
        {
            "trigger": "tiles",
            "annotation": "Asset_Tilemap",
            "kind": "snippet"
        },
        {
            "trigger": "id",
            "annotation": "Anim_Sequence",
            "kind": "snippet"
        },
        {
            "trigger": "name",
            "annotation": "Anim_Sequence",
            "kind": "snippet"
        },
        {
            "trigger": "address",
            "annotation": "Anim_Sequence",
            "kind": "snippet"
        },
        {
            "trigger": "spriteSet",
            "annotation": "Anim_Sequence",
            "kind": "snippet"
        },
        {
            "trigger": "startFrame",
            "annotation": "Anim_Sequence",
            "kind": "snippet"
        },
        {
            "trigger": "endFrame",
            "annotation": "Anim_Sequence",
            "kind": "snippet"
        },
        {
            "trigger": "S65_AddToMemoryReport",
            "annotation": "name",
            "contents": "S65_AddToMemoryReport(${1:name})",
            "kind": "snippet",
            "details": "Measures the byte size of a block of assembly and records it in the memory report output by <a href=\"#Global_MemoryReport\">S65_MemoryReport</a><br><br> Called at the start and the end of the code block you wish to measure by passing the same name in both"
        },
        {
            "trigger": "S65_MemoryReport",
            "annotation": "",
            "contents": "S65_MemoryReport()",
            "kind": "snippet",
            "details": "Called at the very end of your program code this macro will produce a report of the memory used in each of the framework calls"
        },
        {
            "trigger": "S65_RestoreBasePage",
            "annotation": "",
            "contents": "S65_RestoreBasePage()",
            "kind": "snippet",
            "details": "Restores the base page from S65_LastBasePage"
        },
        {
            "trigger": "S65_RestoreRegisters",
            "annotation": "",
            "contents": "S65_RestoreRegisters()",
            "kind": "snippet",
            "details": "Pulls the AXYZ registers off the stack"
        },
        {
            "trigger": "S65_SaveRegisters",
            "annotation": "",
            "contents": "S65_SaveRegisters()",
            "kind": "snippet",
            "details": "Pushes the AXYZ registers onto the stack"
        },
        {
            "trigger": "S65_SetBasePage",
            "annotation": "",
            "contents": "S65_SetBasePage()",
            "kind": "snippet",
            "details": "Saves the current base page in S65_LastBasePage and sets the base page to the S65 Base page area"
        },
        {
            "trigger": "S65_Text16",
            "annotation": "str",
            "contents": "S65_Text16(${1:str})",
            "kind": "snippet",
            "details": "Generates a string of 16 bit words based on the text input. The upper nybblwe of each word is $00 and the lower nybble is the normal 8 bit .screencode encoded value. terminates the string with $ffff"
        },
        {
            "trigger": "S65_Trace",
            "annotation": "str",
            "contents": "S65_Trace(${1:str})",
            "kind": "snippet",
            "details": "Outputs a string to the kick assembler console at build time"
        },
        {
            "trigger": "S65_COLOR_RAM",
            "annotation": "Defaults to $ff80000",
            "kind": "snippet",
            "details": "Defaults to $ff80000"
        },
        {
            "trigger": "S65_ColorRamPointer",
            "annotation": "{dword} S65 BasePage pointer into color ram. It is guaranteed to have the upper two bytes set at all times so can be used to access the color ram using 32bit indirect z addressing. DO NOT change bytes 2 and 3!<br><br> Note: Requires <a href=\"#Global_SetBasePage\">S65_SetBasePage</a> or <a href=\"#Layer_SetScreenPointersXY\">Layer_SetScreenPointersXY</a> to correctly set up the base page before using indirect indexed adressing modes.",
            "kind": "snippet",
            "details": "{dword} S65 BasePage pointer into color ram. It is guaranteed to have the upper two bytes set at all times so can be used to access the color ram using 32bit indirect z addressing. DO NOT change bytes 2 and 3!<br><br> Note: Requires <a href=\"#Global_SetBasePage\">S65_SetBasePage</a> or <a href=\"#Layer_SetScreenPointersXY\">Layer_SetScreenPointersXY</a> to correctly set up the base page before using indirect indexed adressing modes."
        },
        {
            "trigger": "S65_LastImportPtr",
            "annotation": "Contains the address at which the last Asset_Import macro finished importing. Useful for chaining imports together",
            "kind": "snippet",
            "details": "Contains the address at which the last Asset_Import macro finished importing. Useful for chaining imports together"
        },
        {
            "trigger": "S65_LastLayerIOPointer",
            "annotation": "{word} S65 BasePage pointer into to the IO data for the last layer that was fetched using <a href=\"#Layer_Get\">Layer_Get</a>",
            "kind": "snippet",
            "details": "{word} S65 BasePage pointer into to the IO data for the last layer that was fetched using <a href=\"#Layer_Get\">Layer_Get</a>"
        },
        {
            "trigger": "S65_LastSpriteIOPointer",
            "annotation": "{word} S65 BasePage pointer into to the IO data for the last sprite that was fetched using <a href=\"#Sprite_Get\">Sprite_Get</a>",
            "kind": "snippet",
            "details": "{word} S65 BasePage pointer into to the IO data for the last sprite that was fetched using <a href=\"#Sprite_Get\">Sprite_Get</a>"
        },
        {
            "trigger": "S65_ReturnValue",
            "annotation": "{word} S65 BasePage value that is used as a return for many commands when the result is a word rather than a byte.",
            "kind": "snippet",
            "details": "{word} S65 BasePage value that is used as a return for many commands when the result is a word rather than a byte."
        },
        {
            "trigger": "S65_SCREEN_LOGICAL_ROW_WIDTH",
            "annotation": "Number of bytes that make up an entire screen row",
            "kind": "snippet",
            "details": "Number of bytes that make up an entire screen row"
        },
        {
            "trigger": "S65_SCREEN_RAM",
            "annotation": "Defaults to $0800",
            "kind": "snippet",
            "details": "Defaults to $0800"
        },
        {
            "trigger": "S65_SCREEN_ROW_WIDTH",
            "annotation": "Number of characters that make up an entire screen row",
            "kind": "snippet",
            "details": "Number of characters that make up an entire screen row"
        },
        {
            "trigger": "S65_SCREEN_TERMINATOR_OFFSET",
            "annotation": "Screen row offset for the row terminator bytes",
            "kind": "snippet",
            "details": "Screen row offset for the row terminator bytes"
        },
        {
            "trigger": "S65_ScreenPixelHeight",
            "annotation": "Contains the height of the visible screen in pixels",
            "kind": "snippet",
            "details": "Contains the height of the visible screen in pixels"
        },
        {
            "trigger": "S65_ScreenPixelWidth",
            "annotation": "Contains the width of the visible screen in pixels",
            "kind": "snippet",
            "details": "Contains the width of the visible screen in pixels"
        },
        {
            "trigger": "S65_ScreenRamPointer",
            "annotation": "{dword} S65 BasePage pointer into screen ram. It is guaranteed to have the upper two bytes set at all times so can be used to access the screen ram using 32bit indirect z addressing. DO NOT change bytes 2 and 3!<br><br>  For this reason you MUST use a Screen RAM location that does not cross a 64kb boundary and aligned to page boundarys as the engine assumes this for speed<br><br>  Note: Requires <a href=\"#Global_SetBasePage\">S65_SetBasePage</a> or <a href=\"#Layer_SetScreenPointersXY\">Layer_SetScreenPointersXY</a> to correctly set up the base page before using indirect indexed adressing modes.",
            "kind": "snippet",
            "details": "{dword} S65 BasePage pointer into screen ram. It is guaranteed to have the upper two bytes set at all times so can be used to access the screen ram using 32bit indirect z addressing. DO NOT change bytes 2 and 3!<br><br>  For this reason you MUST use a Screen RAM location that does not cross a 64kb boundary and aligned to page boundarys as the engine assumes this for speed<br><br>  Note: Requires <a href=\"#Global_SetBasePage\">S65_SetBasePage</a> or <a href=\"#Layer_SetScreenPointersXY\">Layer_SetScreenPointersXY</a> to correctly set up the base page before using indirect indexed adressing modes."
        },
        {
            "trigger": "S65_SpareBasePage",
            "annotation": "16 bytes of spare storage free for use when the S65 base page is active to assist with using commands that expect to be in S65 base page",
            "kind": "snippet",
            "details": "16 bytes of spare storage free for use when the S65 base page is active to assist with using commands that expect to be in S65 base page"
        },
        {
            "trigger": "S65_VISIBLE_SCREEN_CHAR_HEIGHT",
            "annotation": "Height of the visible screen background layer in characters",
            "kind": "snippet",
            "details": "Height of the visible screen background layer in characters"
        },
        {
            "trigger": "S65_VISIBLE_SCREEN_CHAR_WIDTH",
            "annotation": "Width of the visible screen background layer in characters",
            "kind": "snippet",
            "details": "Width of the visible screen background layer in characters"
        },
        {
            "trigger": "Anim_Define",
            "annotation": "name,spriteSet,start,end",
            "contents": "Anim_Define(${1:name}, ${2:spriteSet}, ${3:start}, ${4:end})",
            "kind": "snippet",
            "details": "Defines an animation sequence"
        },
        {
            "trigger": "Anim_Get",
            "annotation": "name",
            "contents": "Anim_Get(${1:name})",
            "kind": "snippet",
            "details": "Returns the animation sequence object"
        },
        {
            "trigger": "Anim_Sequence",
            "annotation": "The object returned by Anim_Get  / truct Anim_Sequence { id, name, address, spriteSet, startFrame, endFrame}   *",
            "kind": "snippet",
            "details": "The object returned by Anim_Get  / truct Anim_Sequence { id, name, address, spriteSet, startFrame, endFrame}   *"
        },
        {
            "trigger": "Asset_AddExternal",
            "annotation": "name,data",
            "contents": "Asset_AddExternal(${1:name}, ${2:data})",
            "kind": "snippet",
            "details": "Adds a new external asset file to the SDCard containing the binary data providewd. It can then be loaded later using the name provided"
        },
        {
            "trigger": "Asset_EndExternal",
            "annotation": "",
            "contents": "Asset_EndExternal()",
            "kind": "snippet",
            "details": "Ends the data/code block that was previously started with an Asset_StartExternal and returns the program counter to where it was prior to starting the block."
        },
        {
            "trigger": "Asset_ImportCharset",
            "annotation": "name,path,address",
            "contents": "Asset_ImportCharset(${1:name}, ${2:path}, ${3:address})",
            "kind": "snippet",
            "details": "Helper function to preload the _chars file generated by png65 into a given address and load the _ncm file <br> When loading using these imports you only need the first part of the path and file name. eg<br><br> Asset_ImportCharset(\"map\",\"assets/bin/tileset1\", $8000)<br><br> Will load both the \"assets/bin/tileset1_chars.bin\" and the \"assets/bin/tileset1_ncm.s\" files. NOTE: MUST be called before the Layer_InitScreen"
        },
        {
            "trigger": "Asset_ImportCharsetPalette",
            "annotation": "name",
            "contents": "Asset_ImportCharsetPalette(${1:name})",
            "kind": "snippet",
            "details": "Data generation macro that imports the full 256 color palette for the given charset name. The charset must be imported already otherwise this will fail."
        },
        {
            "trigger": "Asset_ImportSpriteset",
            "annotation": "name,charpath,address",
            "contents": "Asset_ImportSpriteset(${1:name}, ${2:charpath}, ${3:address})",
            "kind": "snippet",
            "details": "Helper function to preload the sprites _chars file generated by png65 into a given address and load the _meta file <br> S65 provides space for up to 16 sprite set imports at any one time<br> When loading using these imports you only need the first part of the path and file name. eg<br><br> Asset_ImportSpriteset(\"player\",\"assets/bin/sprites1\", $8000)<br><br> Will load both the \"assets/bin/sprites1_chars.bin\" and the \"assets/bin/sprites1_meta.s\" files. NCM or FCM is determined from the metafile<br><br> NOTE: MUST be called before the Layer_InitScreen"
        },
        {
            "trigger": "Asset_ImportSpritesetPalette",
            "annotation": "name",
            "contents": "Asset_ImportSpritesetPalette(${1:name})",
            "kind": "snippet",
            "details": "Data generation macro that imports the full 256 color palette for the given spriteset name. The spriteset must be imported already otherwise this will fail."
        },
        {
            "trigger": "Asset_ImportTilemap",
            "annotation": "name,path,charset,address",
            "contents": "Asset_ImportTilemap(${1:name}, ${2:path}, ${3:charset}, ${4:address})",
            "kind": "snippet",
            "details": "Helper function to preload the _tiles and _map file generated by ldtk65 into a given address<br> When loading using these imports you only need the first part of the path and file name. eg<br><br> Asset_ImportTilemap(\"map\",\"assets/bin/map\", $8000)<br><br> Will load both the \"assets/bin/map_tiles.bin\" and the \"assets/bin/map_map.s\" files. NOTE: MUST be called before the Layer_InitScreen"
        },
        {
            "trigger": "Asset_LoadFromExternal",
            "annotation": "name,address",
            "contents": "Asset_LoadFromExternal(${1:name}, ${2:address})",
            "kind": "snippet",
            "details": "Loads an external asset previosuly defined using Asset_AddExternal or Asset_StartExternal from SDcard into the memory address provided"
        },
        {
            "trigger": "Asset_Preload",
            "annotation": "",
            "contents": "Asset_Preload()",
            "kind": "snippet",
            "details": "Internal macro used to preload assets when imports have been done at or above $f000. Before initialisation any preloaded assets get loaded here"
        },
        {
            "trigger": "Asset_StartExternal",
            "annotation": "name",
            "contents": "Asset_StartExternal(${1:name})",
            "kind": "snippet",
            "details": "Signals the start of a blcok of data/code that will be saved to the SDCard for importing at runtime.<br> NOTE: If you are using this to save code make sure to use .pseudopc directive to set your intended load address as the program counter will be reset to $0000 for this"
        },
        {
            "trigger": "Asset_GetCharset",
            "annotation": "name",
            "contents": "Asset_GetCharset(${1:name})",
            "kind": "snippet",
            "details": "This method returns the charset object containing all the vars needed to perform many operations.<br><br>  id - The numerical id of the charset assigned by Asset_ImportCharset<br> name - The name of the charset<br> address - The start address for the charset char data <br> colorAddress - The start address for the color table if present<br> palette - A {List} of bytes containing the palette data <br> colors - A {List} of bytes containing the ncm color mapping data <br>"
        },
        {
            "trigger": "Asset_GetSpriteset",
            "annotation": "name",
            "contents": "Asset_GetSpriteset(${1:name})",
            "kind": "snippet",
            "details": "Sprite sets are assigned numerical values from 0 to 15 in order as they are imported. This method returns the spriteset object containing all the vars needed to perform many operations, .id is used whenever referencing a spriteset in commands e.g. <a href=\"#Sprite_SetSpriteMeta\">Sprite_SetSpriteMeta</a><br><br>  id - The numerical id of the spriteset assigned by Asset_ImportSpriteset<br> name - The name of the spriteset<br> address - The start address for the spriteset char data <br> metaAddress - The start address for the spriteset metadata <br> meta - A {List} of bytes containing the metadata<br> palette - A {List} of bytes containing the palette data <br>"
        },
        {
            "trigger": "Asset_GetTilemap",
            "annotation": "name",
            "contents": "Asset_GetTilemap(${1:name})",
            "kind": "snippet",
            "details": "This method returns the tilemap object containing all the vars needed to perform many operations.<br><br>  NOTE: The first four bytes of the tilemap data are thew width and height of the map in tiles (16 bit word values)<br><br>  id - The numerical id of the tilemap assigned by Asset_ImportTilemap<br> name - The name of the tilemap<br> tilemapAddress - The start address for the tilemap data<br> tiledefAddress - The start address for the tile definition data<br> tilemap - A {List} of bytes containing the tilemap data <br> tiles - A {List} of bytes containing the tile definiton data<br>"
        },
        {
            "trigger": "Asset_Charset",
            "annotation": "The object returned by GetCharset",
            "kind": "snippet",
            "details": "The object returned by GetCharset"
        },
        {
            "trigger": "Asset_Spriteset",
            "annotation": "The object returned by GetSpriteset",
            "kind": "snippet",
            "details": "The object returned by GetSpriteset"
        },
        {
            "trigger": "Asset_Tilemap",
            "annotation": "The object returned by GetTilemap",
            "kind": "snippet",
            "details": "The object returned by GetTilemap"
        },
        {
            "trigger": "Asset_Asset_SpriteListMetaTable",
            "annotation": "Pointer to the lookup table for the spritesets meta data tables",
            "kind": "snippet",
            "details": "Pointer to the lookup table for the spritesets meta data tables"
        },
        {
            "trigger": "DMA_CopyJob",
            "annotation": "source:destination:length:chain:backwards",
            "contents": "DMA_CopyJob ${1:source} : ${2:destination} : ${3:length} : ${4:chain} : ${5:backwards}",
            "kind": "snippet",
            "details": "Data generator that copys a defined number of bytes from one location in memory to another using the DMagic chip @ 20mb/s <br>This is NOT executable code, only data and should be used as such<br><br>"
        },
        {
            "trigger": "DMA_DisableTransparency",
            "annotation": "",
            "contents": "DMA_DisableTransparency ",
            "kind": "snippet",
            "details": "Data generator that disables the transparent byte masking. This is the default state. <br>This is NOT executable code, only data and should be used as such<br><br>"
        },
        {
            "trigger": "DMA_EnableTransparency",
            "annotation": "transparentByte",
            "contents": "DMA_EnableTransparency ${1:transparentByte}",
            "kind": "snippet",
            "details": "Data generator that enables transparent byte masking. This will ignore any source bytes that match the given byte and leave the destination byte untouched. <br>This is NOT executable code, only data and should be used as such<br><br>"
        },
        {
            "trigger": "DMA_Execute",
            "annotation": "address",
            "contents": "DMA_Execute ${1:address}",
            "kind": "snippet",
            "details": "Executes the DMagic job at the given address."
        },
        {
            "trigger": "DMA_FillJob",
            "annotation": "sourceByte:destination:length:chain",
            "contents": "DMA_FillJob ${1:sourceByte} : ${2:destination} : ${3:length} : ${4:chain}",
            "kind": "snippet",
            "details": "Data generator that fills a defined number of bytes from one location in memory to another using the DMagic chip @ 40mb/s <br>This is NOT executable code, only data and should be used as such<br><br>"
        },
        {
            "trigger": "DMA_Header",
            "annotation": "sourceBank:destBank",
            "contents": "DMA_Header ${1:sourceBank} : ${2:destBank}",
            "kind": "snippet",
            "details": "Data generator that sets the DMagic header bytes defining the source and destination banks.<br>This is NOT executable code, only data and should be used as such<br><br> Note: The bank number of a memory adress is its 5th and 6th nybble. e.g. $ff80000 is bank number $ff"
        },
        {
            "trigger": "DMA_Step",
            "annotation": "sourceStep:destStep",
            "contents": "DMA_Step ${1:sourceStep} : ${2:destStep}",
            "kind": "snippet",
            "details": "Data generator that sets the source and/or destination stepping values. The DMA will use a fixed point step for each increment on the source and destination by default they are both set to the fixed point 8:8 value $0100 (or 1.0 in decimal) <br>This is NOT executable code, only data and should be used as such<br><br>"
        },
        {
            "trigger": "DMA_F018_DMA_11_byte_format",
            "annotation": "Offsets into the DMagic job for the <a target=\"_blank\" href=\"#https://files.mega65.org/manuals-upload/mega65-chipset-reference.pdf#F018%20DMA%20Job%20List%20Format\">F018 11 byte data format</a>.",
            "kind": "snippet",
            "details": "Offsets into the DMagic job for the <a target=\"_blank\" href=\"#https://files.mega65.org/manuals-upload/mega65-chipset-reference.pdf#F018%20DMA%20Job%20List%20Format\">F018 11 byte data format</a>."
        },
        {
            "trigger": "Debug_AddWatcher",
            "annotation": "label,address",
            "contents": "Debug_AddWatcher(${1:label}, ${2:address})",
            "kind": "snippet",
            "details": "Creates a watcher that is then displayed in the debug overlay. 4 bytes at a time are watcehd at each address. Best declared directly after your S65 library import.  Requires NODEBUG to NOT be defined"
        },
        {
            "trigger": "Layer_AddText",
            "annotation": "xpos:ypos:textPtr:color",
            "contents": "Layer_AddText ${1:xpos} : ${2:ypos} : ${3:textPtr} : ${4:color}",
            "kind": "snippet",
            "details": "Writes a string of bytes to the currently active layer at the provide co-ordinates. Optionally allows the use of color, setting Color RAM Byte 1 all bits (so includes bit4-blink, bit5-reverse, bit6-bold and bit7-underline), this will only work on non NCM layers with char indices less than $100 <br> This is a conveinience function it is better to use Layer_WriteToScreen as it is more efficient<br><br> Note: As layer screen rows are interlaced in memory, its important to not let the string extend off the right edge of the layer as it can break the RRB on other layers. There is an upper limit string length of 128"
        },
        {
            "trigger": "Layer_AdvanceScreenPointers",
            "annotation": "Optional",
            "contents": "Layer_AdvanceScreenPointers ${1:Optional}",
            "kind": "snippet",
            "details": "Advances the S65 Basepage dword values for <a href=\"#Global_ColorRamPointer\">ColorRamPointer<a> and <a href=\"#Global_ScreenRamPointer\">ScreenRamPointer<a> by the given byte offset.<br><br>  Note: This method assumes you are already in the S65 base page, this is true after a <a href=\"#Layer_Get\">Layer_Get</a> command, be careful not to use this command if base page is not set, otherwise it will likely write to unintended locations"
        },
        {
            "trigger": "Layer_ClearAllLayers",
            "annotation": "clearChar",
            "contents": "Layer_ClearAllLayers ${1:clearChar}",
            "kind": "snippet",
            "details": "Fills the screen RAM area for ALL layers with a given 16bit value. Note this will overwrite any RRB GotoX markers also<br> NOTE: Absolute addressing will fetch 2 bytes from the target address (aka ABS16)<br>"
        },
        {
            "trigger": "Layer_ClearLayer",
            "annotation": "clearChar:clearColor",
            "contents": "Layer_ClearLayer ${1:clearChar} : ${2:clearColor}",
            "kind": "snippet",
            "details": "Fills the screen RAM area for the currently selected layer with a given 16bit value. Optionally clearing the color too"
        },
        {
            "trigger": "Layer_Get",
            "annotation": "layerNum",
            "contents": "Layer_Get ${1:layerNum}",
            "kind": "snippet",
            "details": "This method sets the currently active layer for all Layer commands.<br><br> Note: This method will also call <a href=\"#S65_SetBasePage\">S65_SetBasePage</a> which is required for the Layer functions"
        },
        {
            "trigger": "Layer_GetGotoX",
            "annotation": "",
            "contents": "Layer_GetGotoX ",
            "kind": "snippet",
            "details": "Returns the gotox value for the current selected layer into <a href=\"#Global_ReturnValue\">S65_ReturnValue</a>"
        },
        {
            "trigger": "Layer_SetGotoX",
            "annotation": "gotox",
            "contents": "Layer_SetGotoX ${1:gotox}",
            "kind": "snippet",
            "details": "Sets the gotox value for the current selected layer so that it is rendered in a <a href=\"#Layer_Update\">Layer_Update</a> with a new shifted X position<br> NOTE: Absolute addressing will fetch 2 bytes from the target address (aka ABS16)<br>"
        },
        {
            "trigger": "Layer_SetScreenPointersXY",
            "annotation": "xpos:ypos",
            "contents": "Layer_SetScreenPointersXY ${1:xpos} : ${2:ypos}",
            "kind": "snippet",
            "details": "Sets the basepage to point to the S65 base page area and then sets screen and color ram pointers <a href=\"#Global_ScreenRamPointer\">ScreenRamPointer<a> and <a href=\"#Global_ColorRamPointer\">ColorRamPointer<a> to point to the given layers x and y co-ordinate"
        },
        {
            "trigger": "Layer_Shift",
            "annotation": "xshift",
            "contents": "Layer_Shift ${1:xshift}",
            "kind": "snippet",
            "details": "Shift the cahrs on this layer horizontally"
        },
        {
            "trigger": "Layer_SortSprites",
            "annotation": "count",
            "contents": "Layer_SortSprites ${1:count}",
            "kind": "snippet",
            "details": "Y sorts the sprite render order for this layer, using the sprite y pos + its height as a base"
        },
        {
            "trigger": "Layer_Update",
            "annotation": "",
            "contents": "Layer_Update ",
            "kind": "snippet",
            "details": "Updates ALL the layers. This is basically the render method, it sets all the GOTOX markers for the various layers and calls the Sprite_Update method<br><br> Note: this is an expensive operation in both memory and cpu, it should be called once only per frame and put it in a subroutine if you need to call it from more than one place"
        },
        {
            "trigger": "Layer_WriteToScreen",
            "annotation": "screenSource:colorSource:size",
            "contents": "Layer_WriteToScreen ${1:screenSource} : ${2:colorSource} : ${3:size}",
            "kind": "snippet",
            "details": "Copys up to 256 bytes from the source addresses to the locations pointed at by <a href=\"#Global_ScreenRamPointer\">ScreenRamPointer<a> and optionally <a href=\"#Global_ColorRamPointer\">ColorRamPointer<a>. Does NOT change the contents of the screen and color ram pointers.<br> If immediate values are used for source then this byte is written directly<br><br> Note: This method assumes you are already in the S65 base page, this is true after a <a href=\"#Layer_Get\">Layer_Get</a> command, be careful not to use this command if base page is not set, otherwise it will likely write to unintended locations<br> If ABSY mode is used for either source then the y register is added to the address before writing. Additionally upon completion the Y register will be incremented by the amount of bytes written<br><br> Note: Writing past the end of your layers right edge can cause RRB and memory issues please use <a href=\"#Layer_AdvanceScreenPointers\">Layer_AdvanceScreenPointers<a> to move the pointers safely to the next row"
        },
        {
            "trigger": "Layer_DefineRRBSpriteLayer",
            "annotation": "charsPerLine,maxSprites",
            "contents": "Layer_DefineRRBSpriteLayer(${1:charsPerLine}, ${2:maxSprites})",
            "kind": "snippet",
            "details": "Defines a new RRB Sprite layer in Screen RAM. RRB Sprite layers are always NCM mode (16x8px chars). IO for this layer is assigned to the Layer IO dynamic memory area<br> Note that chars per line is NOT the max sprites per line as a sprite can be any multiple of 16 chars wide<br><br>   RRB Sprite space is a buffer limited by a set amount of chars per line. During an update each new Sprite uses a GOTOX marker and however many RRB chars wide it is. So, for example, a 32x32 RRB sprite is 2 chars wide + a GOTOX marker so will take 3 chars of space.<br><br> Note: There is a RRB Sprite hard limit of 256 per RRB Sprite layer.  The majority of the memory and cpu time consumed by the RRB Sprite system is a result of the number of maxSprites. Reducing this number will have the best impact on SpriteIO area memory usage as each sprite slot (regardless if its enabled or not in <a href=\"#Sprite_IOflags\">Sprite_IOflags</a>will use at least 10 bytes each. And every sprite that IS enabled will use some cpu time to update."
        },
        {
            "trigger": "Layer_DefineResolution",
            "annotation": "charWidth,charHeight,stretchWide",
            "contents": "Layer_DefineResolution(${1:charWidth}, ${2:charHeight}, ${3:stretchWide})",
            "kind": "snippet",
            "details": "Defines the screen resolution in 8x8 charachters (regardless if NCM is being used) and if it should be stretched horizontally to fit the width of the display. <a href=\"##Layer_InitScreen\">Layer_InitScreen</a> will configure the borders and TEXTXPOS and TEXTYPOS to center the screen on the display.<br><br>  NOTE:<br> - charHeight above 32 will use V400 mode and disable any RRB double buffering and double rate RRB<br> - charWidth above 42 will use H640 mode<br>"
        },
        {
            "trigger": "Layer_DefineScreenLayer",
            "annotation": "charWidth,offsetX,ncm",
            "contents": "Layer_DefineScreenLayer(${1:charWidth}, ${2:offsetX}, ${3:ncm})",
            "kind": "snippet",
            "details": "Defines a new screen layer in Screen RAM optionally shifting its RRB GOTOX offset.<br> Note: the maximum charWidth for a layer is 126"
        },
        {
            "trigger": "Layer_InitScreen",
            "annotation": "screenBaseAddress",
            "contents": "Layer_InitScreen(${1:screenBaseAddress})",
            "kind": "snippet",
            "details": "Initialises the MEGA65 and VIC-IV and parses the Layer definitions into a Screen RAM layout"
        },
        {
            "trigger": "Layer_GetColorAddress",
            "annotation": "layerNumber,xpos,ypos",
            "contents": "Layer_GetColorAddress(${1:layerNumber}, ${2:xpos}, ${3:ypos})",
            "kind": "snippet",
            "details": "Returns the address of the color RAM at the given position on this screen layer"
        },
        {
            "trigger": "Layer_GetIO",
            "annotation": "layerNumber,register",
            "contents": "Layer_GetIO(${1:layerNumber}, ${2:register})",
            "kind": "snippet",
            "details": "Returns the base address for the given layer & register.<br> See <a href='#Layer_Vars'>Layer_IO<a> for register list"
        },
        {
            "trigger": "Layer_GetLayerCount",
            "annotation": "",
            "contents": "Layer_GetLayerCount()",
            "kind": "snippet",
            "details": "Returns the current number of layers, useful for assigning to constants to name each layer for use in your code."
        },
        {
            "trigger": "Layer_GetScreenAddress",
            "annotation": "layerNumber,xpos,ypos",
            "contents": "Layer_GetScreenAddress(${1:layerNumber}, ${2:xpos}, ${3:ypos})",
            "kind": "snippet",
            "details": "Returns the address of the char at the given position on this screen layer"
        },
        {
            "trigger": "Layer_GotoXColorPositions",
            "annotation": "Table of GOTOX Attribute in color ram for each layer",
            "kind": "snippet",
            "details": "Table of GOTOX Attribute in color ram for each layer"
        },
        {
            "trigger": "Layer_GotoXPositions",
            "annotation": "Table of current GOTOX positions for all the layers",
            "kind": "snippet",
            "details": "Table of current GOTOX positions for all the layers"
        },
        {
            "trigger": "Layer_LayerWidth",
            "annotation": "Table of start address offsets for each layer",
            "kind": "snippet",
            "details": "Table of start address offsets for each layer"
        },
        {
            "trigger": "Layer_LogicalWidth",
            "annotation": "Contains the current Screen Row Logical Width in bytes",
            "kind": "snippet",
            "details": "Contains the current Screen Row Logical Width in bytes"
        },
        {
            "trigger": "Layer_AddrOffsets",
            "annotation": "Pointer to Table of start address offsets for each layer",
            "kind": "snippet",
            "details": "Pointer to Table of start address offsets for each layer"
        },
        {
            "trigger": "Layer_DMAClear",
            "annotation": "Pointer to a dma subroutine that clears the screen ram layer, A=layer, X=charLo, Y=charHi",
            "kind": "snippet",
            "details": "Pointer to a dma subroutine that clears the screen ram layer, A=layer, X=charLo, Y=charHi"
        },
        {
            "trigger": "Layer_DMAClearColor",
            "annotation": "Pointer to a dma subroutine that clears the color ram layer, A=layer, X=color",
            "kind": "snippet",
            "details": "Pointer to a dma subroutine that clears the color ram layer, A=layer, X=color"
        },
        {
            "trigger": "Layer_DMAClearColorRRB",
            "annotation": "Pointer to a dma subroutine that clears the color ram layer for RRB sprites, A=layer",
            "kind": "snippet",
            "details": "Pointer to a dma subroutine that clears the color ram layer for RRB sprites, A=layer"
        },
        {
            "trigger": "Layer_DynamicDataTable",
            "annotation": "A pointer to the table containing the address of each layers dynamic data, this memory is initialised on a <a href='#Layer_InitScreen'>Layer_InitScreen</a> it's size is dependant on the screen layer structure, RRB sprite layers use the most memory",
            "kind": "snippet",
            "details": "A pointer to the table containing the address of each layers dynamic data, this memory is initialised on a <a href='#Layer_InitScreen'>Layer_InitScreen</a> it's size is dependant on the screen layer structure, RRB sprite layers use the most memory"
        },
        {
            "trigger": "Layer_IOgotoX",
            "annotation": "The IO register index for this layers GOTOX value. Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function.",
            "kind": "snippet",
            "details": "The IO register index for this layers GOTOX value. Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function."
        },
        {
            "trigger": "Layer_IOmaxCharsRRB",
            "annotation": "RRB SPRITE LAYER ONLY. The IO register index for this layers maximum chars per line value. <br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function.",
            "kind": "snippet",
            "details": "RRB SPRITE LAYER ONLY. The IO register index for this layers maximum chars per line value. <br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function."
        },
        {
            "trigger": "Layer_IOmaxSpritesRRB",
            "annotation": "RRB SPRITE LAYER ONLY. The IO register index for this layers maximum sprites value.<br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function.",
            "kind": "snippet",
            "details": "RRB SPRITE LAYER ONLY. The IO register index for this layers maximum sprites value.<br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function."
        },
        {
            "trigger": "Layer_IOrowCountTableRRB",
            "annotation": "RRB SPRITE LAYER ONLY. The IO register index for this layers RRB sprite rowCharCount table, used internally by the RRB sprite system.<br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function.",
            "kind": "snippet",
            "details": "RRB SPRITE LAYER ONLY. The IO register index for this layers RRB sprite rowCharCount table, used internally by the RRB sprite system.<br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function."
        },
        {
            "trigger": "Layer_IsRRBSprite",
            "annotation": "Pointer to the table of flags indicating if layers are RRB sprite layer",
            "kind": "snippet",
            "details": "Pointer to the table of flags indicating if layers are RRB sprite layer"
        },
        {
            "trigger": "Layer_RowAddressBaseLSB",
            "annotation": "Pointer to the table of LSB values for the address of the start of each screen row directly",
            "kind": "snippet",
            "details": "Pointer to the table of LSB values for the address of the start of each screen row directly"
        },
        {
            "trigger": "Layer_RowAddressBaseMSB",
            "annotation": "Pointer to the table of MSB values for the address of the start of each screen row directly",
            "kind": "snippet",
            "details": "Pointer to the table of MSB values for the address of the start of each screen row directly"
        },
        {
            "trigger": "Layer_RowAddressLSB",
            "annotation": "Pointer to the table of LSB values for the address of the start of each screen row directly after the first GOTOX",
            "kind": "snippet",
            "details": "Pointer to the table of LSB values for the address of the start of each screen row directly after the first GOTOX"
        },
        {
            "trigger": "Layer_RowAddressMSB",
            "annotation": "Pointer to the table of MSB values for the address of the start of each screen row directly after the first GOTOX",
            "kind": "snippet",
            "details": "Pointer to the table of MSB values for the address of the start of each screen row directly after the first GOTOX"
        },
        {
            "trigger": "Layer_SpriteCount",
            "annotation": "How many sprites there are max in this layer",
            "kind": "snippet",
            "details": "How many sprites there are max in this layer"
        },
        {
            "trigger": "Layer_SpriteIOAddrLSB",
            "annotation": "Pointer to the table of LSB values for the address of the start of the layers sprite IO area",
            "kind": "snippet",
            "details": "Pointer to the table of LSB values for the address of the start of the layers sprite IO area"
        },
        {
            "trigger": "Layer_SpriteIOAddrMSB",
            "annotation": "Pointer to the table of MSB values for the address of the start of the layers sprite IO area",
            "kind": "snippet",
            "details": "Pointer to the table of MSB values for the address of the start of the layers sprite IO area"
        },
        {
            "trigger": "Layer_SpriteSortListLSB",
            "annotation": "Pointer to the LSB of table of sorted sprite indices",
            "kind": "snippet",
            "details": "Pointer to the LSB of table of sorted sprite indices"
        },
        {
            "trigger": "Layer_SpriteSortListMSB",
            "annotation": "Pointer to the MSB of table of sorted sprite indices",
            "kind": "snippet",
            "details": "Pointer to the MSB of table of sorted sprite indices"
        },
        {
            "trigger": "Palette_Assign",
            "annotation": "palleteChar:paletteHWSprite:paletteRRBSprite",
            "contents": "Palette_Assign ${1:palleteChar} : ${2:paletteHWSprite} : ${3:paletteRRBSprite}",
            "kind": "snippet",
            "details": "Assigns palettes to the MEGA65 palette banks."
        },
        {
            "trigger": "Palette_Cycle",
            "annotation": "from:count",
            "contents": "Palette_Cycle ${1:from} : ${2:count}",
            "kind": "snippet",
            "details": "Cycles a range of colors in the current palette shifting them in a loop by 1 backwards"
        },
        {
            "trigger": "Palette_LoadFromMem",
            "annotation": "addr:size",
            "contents": "Palette_LoadFromMem ${1:addr} : ${2:size}",
            "kind": "snippet",
            "details": "Copys palette data from a given address into the currently active palette."
        },
        {
            "trigger": "Palette_LoadFromSD",
            "annotation": "addr",
            "contents": "Palette_LoadFromSD ${1:addr}",
            "kind": "snippet",
            "details": "Loads a full 256 color palette from SD card into the currently active palette"
        },
        {
            "trigger": "Palette_Set",
            "annotation": "paletteNum",
            "contents": "Palette_Set ${1:paletteNum}",
            "kind": "snippet",
            "details": "Sets the currently active palette in IO memory."
        },
        {
            "trigger": "Palette_LoadFromExternal",
            "annotation": "name",
            "contents": "Palette_LoadFromExternal(${1:name})",
            "kind": "snippet",
            "details": "Loads a full 256 color palette from SD card into the currently active palette using the name referenced in a <a href=\"#Asset_AddExternal\">Asset_AddExternal</a>"
        },
        {
            "trigger": "Palette_MEGA65_Palette",
            "annotation": "The MEGA65 has up to 4 palettes that can be assigned to the various graphic types Sprite and Character. At any one time one of the palettes will be banked into IO memory at $d100-$d3ff.  Note: While the palette format is RGB788 the nybbles of each byte are switched e.g. $F0 becomes $0F, to maintain compatibility with the C65",
            "kind": "snippet",
            "details": "The MEGA65 has up to 4 palettes that can be assigned to the various graphic types Sprite and Character. At any one time one of the palettes will be banked into IO memory at $d100-$d3ff.  Note: While the palette format is RGB788 the nybbles of each byte are switched e.g. $F0 becomes $0F, to maintain compatibility with the C65"
        },
        {
            "trigger": "Palette_0",
            "annotation": "MEGA65 palette 0",
            "kind": "snippet",
            "details": "MEGA65 palette 0"
        },
        {
            "trigger": "Palette_1",
            "annotation": "MEGA65 palette 1",
            "kind": "snippet",
            "details": "MEGA65 palette 1"
        },
        {
            "trigger": "Palette_2",
            "annotation": "MEGA65 palette 2",
            "kind": "snippet",
            "details": "MEGA65 palette 2"
        },
        {
            "trigger": "Palette_3",
            "annotation": "MEGA65 palette 3",
            "kind": "snippet",
            "details": "MEGA65 palette 3"
        },
        {
            "trigger": "SDCard_LoadToAtticRam",
            "annotation": "addr:filePtr",
            "contents": "SDCard_LoadToAtticRam ${1:addr} : ${2:filePtr}",
            "kind": "snippet",
            "details": "Loads a file from the SDCard into attic RAM"
        },
        {
            "trigger": "SDCard_LoadToChipRam",
            "annotation": "addr:filePtr",
            "contents": "SDCard_LoadToChipRam ${1:addr} : ${2:filePtr}",
            "kind": "snippet",
            "details": "Loads a file from the SDCard into chip RAM"
        },
        {
            "trigger": "SDCard_LoadExternalToAtticRam",
            "annotation": "name,name",
            "contents": "SDCard_LoadExternalToAtticRam(${1:name}, ${2:name})",
            "kind": "snippet",
            "details": "Loads a binary from SD card into the attic ram location provided"
        },
        {
            "trigger": "SDCard_LoadExternalToChipRam",
            "annotation": "name,name",
            "contents": "SDCard_LoadExternalToChipRam(${1:name}, ${2:name})",
            "kind": "snippet",
            "details": "Loads a binary from SD card into the chip ram location provided"
        },
        {
            "trigger": "Sprite_Get",
            "annotation": "layerNum:sprNum",
            "contents": "Sprite_Get ${1:layerNum} : ${2:sprNum}",
            "kind": "snippet",
            "details": "This method is a prerequisite for getting or setting any sprites IO registers it sets the \"current active\" sprite used by the Sprite Get and Set methods by storing the pointer to that sprites IO area in <a href=\"#S65_LastSpriteIOPointer\">S65_LastSpriteIOPointer</a><br><br> Note: This method will also call <a href=\"#S65_SetBasePage\">S65_SetBasePage</a> which is required for the subsequent Sprite functions"
        },
        {
            "trigger": "Sprite_GetColor",
            "annotation": "",
            "contents": "Sprite_GetColor ",
            "kind": "snippet",
            "details": "Returns the color of the currently selected sprite in <a href=\"#Global_ReturnValue\">S65_ReturnValue</a> and the accumulator Lo byte is color<br> Note that colors are in the upper nybble in NCM mode, so palette slice $02 is represented as $20"
        },
        {
            "trigger": "Sprite_GetDimensions",
            "annotation": "",
            "contents": "Sprite_GetDimensions ",
            "kind": "snippet",
            "details": "Returns the dimensions of the currently selected sprite into <a href=\"#Global_ReturnValue\">S65_ReturnValue</a><br> Lo byte is width, Hi byte is height"
        },
        {
            "trigger": "Sprite_GetEnabled",
            "annotation": "",
            "contents": "Sprite_GetEnabled ",
            "kind": "snippet",
            "details": "Returns the enabled state of the current selected sprite into <a href=\"#Global_ReturnValue\">S65_ReturnValue</a>"
        },
        {
            "trigger": "Sprite_GetFlags",
            "annotation": "",
            "contents": "Sprite_GetFlags ",
            "kind": "snippet",
            "details": "Returns the flags of the current selected sprite into <a href=\"#Global_ReturnValue\">S65_ReturnValue</a>"
        },
        {
            "trigger": "Sprite_GetPointer",
            "annotation": "",
            "contents": "Sprite_GetPointer ",
            "kind": "snippet",
            "details": "Returns the current pointer of the currently selected sprite into <a href=\"#Global_ReturnValue\">S65_ReturnValue</a>"
        },
        {
            "trigger": "Sprite_GetPositionX",
            "annotation": "",
            "contents": "Sprite_GetPositionX ",
            "kind": "snippet",
            "details": "Returns the X position of the current selected sprite into <a href=\"#Global_ReturnValue\">S65_ReturnValue</a>"
        },
        {
            "trigger": "Sprite_GetPositionY",
            "annotation": "",
            "contents": "Sprite_GetPositionY ",
            "kind": "snippet",
            "details": "Returns the Y position of the current selected sprite into <a href=\"#Global_ReturnValue\">S65_ReturnValue</a>"
        },
        {
            "trigger": "Sprite_ResetFlags",
            "annotation": "flags",
            "contents": "Sprite_ResetFlags ${1:flags}",
            "kind": "snippet",
            "details": "Resets one or more of the currently selected sprites flags. You can use the <a href=\"#Sprite_IOflagEnabled\">flag constants</a> provided by S65 to abstract the values. The other flags are left untouched"
        },
        {
            "trigger": "Sprite_SetAnim",
            "annotation": "animId:speed",
            "contents": "Sprite_SetAnim ${1:animId} : ${2:speed}",
            "kind": "snippet",
            "details": "Sets the sprites animation id and resets its timer and frame counter. A value of 0 turns off the animation and returns control of the sprites pointer to Sprite_IOptr."
        },
        {
            "trigger": "Sprite_SetColor",
            "annotation": "color",
            "contents": "Sprite_SetColor ${1:color}",
            "kind": "snippet",
            "details": "Sets the currently selected sprites color. Note that colors are in the upper nybble in NCM mode, so palette slice $02 is represented as $20"
        },
        {
            "trigger": "Sprite_SetDimensions",
            "annotation": "width:height",
            "contents": "Sprite_SetDimensions ${1:width} : ${2:height}",
            "kind": "snippet",
            "details": "Sets the currently selected sprites width and height. There is a hard limit of 255 chars to make up any one sprite therefore width * height MUST be less than 256"
        },
        {
            "trigger": "Sprite_SetEnabled",
            "annotation": "enabled",
            "contents": "Sprite_SetEnabled ${1:enabled}",
            "kind": "snippet",
            "details": "Enables or disables the current selected sprite so that it is rendered in a <a href=\"#Layer_Update\">Layer_Update</a><br> Sets <a href=\"#Global_LastSpriteIOPointer\">S65_LastSpriteIOPointer</a><br><br>"
        },
        {
            "trigger": "Sprite_SetFlags",
            "annotation": "flags",
            "contents": "Sprite_SetFlags ${1:flags}",
            "kind": "snippet",
            "details": "Sets one or more of the currently selected sprites flags. You can use the <a href=\"#Sprite_IOflagEnabled\">flag constants</a> provided by S65 to abstract the values. The other flags are left untouched"
        },
        {
            "trigger": "Sprite_SetPointer",
            "annotation": "pointer",
            "contents": "Sprite_SetPointer ${1:pointer}",
            "kind": "snippet",
            "details": "Sets the current selected sprite pointer. If pointer is passed as a register it sets ONLY the LSB, MSB sets to 0. If ABS mode is used then two bytes are read from that address and used to set the value"
        },
        {
            "trigger": "Sprite_SetPositionX",
            "annotation": "xpos",
            "contents": "Sprite_SetPositionX ${1:xpos}",
            "kind": "snippet",
            "details": "Sets the current selected sprite X position. If position is passed as a register it sets ONLY the LSB, MSB sets to 0. If ABS mode is used then two bytes are read from that address and used to set the value"
        },
        {
            "trigger": "Sprite_SetPositionY",
            "annotation": "ypos",
            "contents": "Sprite_SetPositionY ${1:ypos}",
            "kind": "snippet",
            "details": "Sets the current selected sprite Y position. If position is passed as a register it sets ONLY the LSB, MSB sets to 0. If ABS mode is used then two bytes are read from that address and used to set the value"
        },
        {
            "trigger": "Sprite_SetSpriteMeta",
            "annotation": "spritesId:spriteNum",
            "contents": "Sprite_SetSpriteMeta ${1:spritesId} : ${2:spriteNum}",
            "kind": "snippet",
            "details": "Enables the currently selected sprite and popualtes its IO registers with the meta data for the given spriteset index. Affects:<br> - IOflags (Enabled, NCM)<br> - IOwidth<br> - IOheight<br> - IOptr<br> - IOcolor<br>"
        },
        {
            "trigger": "Sprite_Update",
            "annotation": "",
            "contents": "Sprite_Update ",
            "kind": "snippet",
            "details": "Called internally by <a href=\"#Layer_Update\">Layer_Update</a><br>"
        },
        {
            "trigger": "Sprite_GenerateLayerData",
            "annotation": "",
            "contents": "Sprite_GenerateLayerData()",
            "kind": "snippet",
            "details": "Internally used macro for assigning sprite IO area during a <a href=\"#Layer_InitScreen\">Layer_InitScreen</a>"
        },
        {
            "trigger": "Sprite_GenerateMetaData",
            "annotation": "",
            "contents": "Sprite_GenerateMetaData()",
            "kind": "snippet",
            "details": "Internally used to generate the runtime lookup tables for sprite meta data"
        },
        {
            "trigger": "Sprite_GetIO",
            "annotation": "layerNumber,spriteNumber,register",
            "contents": "Sprite_GetIO(${1:layerNumber}, ${2:spriteNumber}, ${3:register})",
            "kind": "snippet",
            "details": "Returns the base address for the given layer & IO register.<br> See <a href='#Sprite_Vars'>Sprite_IO<a> for register list"
        },
        {
            "trigger": "Sprite_MetaData",
            "annotation": "This is a byte array used by the engine when Asset_ImportSpriteset and Asset_ImportSpritesetMeta is used to store all the meta data for the sprites such as mappings from sprite to character numbers, colors etc.",
            "kind": "snippet",
            "details": "This is a byte array used by the engine when Asset_ImportSpriteset and Asset_ImportSpritesetMeta is used to store all the meta data for the sprites such as mappings from sprite to character numbers, colors etc."
        },
        {
            "trigger": "Sprite_SequenceData",
            "annotation": "This is a byte array used by the engine for storing animation sequences. Animations are not stored in a table but in a sequential list, specific aniamtion data addresses can be retrievd using Anim_Get().address",
            "kind": "snippet",
            "details": "This is a byte array used by the engine for storing animation sequences. Animations are not stored in a table but in a sequential list, specific aniamtion data addresses can be retrievd using Anim_Get().address"
        },
        {
            "trigger": "Sprite_IOanim",
            "annotation": "Sprites animation id if non zero takes over control of the sprites pointer from Sprite_IOptr",
            "kind": "snippet",
            "details": "Sprites animation id if non zero takes over control of the sprites pointer from Sprite_IOptr"
        },
        {
            "trigger": "Sprite_IOanimFrame",
            "annotation": "Used internally to keep track of the current frame for the sprites animation",
            "kind": "snippet",
            "details": "Used internally to keep track of the current frame for the sprites animation"
        },
        {
            "trigger": "Sprite_IOanimSpeed",
            "annotation": "The speed of the aniamtion, lower=faster, minimum 1",
            "kind": "snippet",
            "details": "The speed of the aniamtion, lower=faster, minimum 1"
        },
        {
            "trigger": "Sprite_IOanimTimer",
            "annotation": "Used internally to keep track of the time per frame for the sprites animation",
            "kind": "snippet",
            "details": "Used internally to keep track of the time per frame for the sprites animation"
        },
        {
            "trigger": "Sprite_IOcolor",
            "annotation": "The color to apply to all the chars in this sprite.",
            "kind": "snippet",
            "details": "The color to apply to all the chars in this sprite."
        },
        {
            "trigger": "Sprite_IOflagEnabled",
            "annotation": "The value to set the enabled bit in <a href=\"#Sprite_IOflags\">Sprite_IOflags</a>",
            "kind": "snippet",
            "details": "The value to set the enabled bit in <a href=\"#Sprite_IOflags\">Sprite_IOflags</a>"
        },
        {
            "trigger": "Sprite_IOflagFlipH",
            "annotation": "The value to set the flip H bit in <a href=\"#Sprite_IOflags\">Sprite_IOflags</a>",
            "kind": "snippet",
            "details": "The value to set the flip H bit in <a href=\"#Sprite_IOflags\">Sprite_IOflags</a>"
        },
        {
            "trigger": "Sprite_IOflagFlipV",
            "annotation": "The value to set the flip V bit in <a href=\"#Sprite_IOflags\">Sprite_IOflags</a><br><br> NOTE: Currently due to HW limitations (missing ROWMASK functionality) this flag will cause rendering issues and should NOT be used",
            "kind": "snippet",
            "details": "The value to set the flip V bit in <a href=\"#Sprite_IOflags\">Sprite_IOflags</a><br><br> NOTE: Currently due to HW limitations (missing ROWMASK functionality) this flag will cause rendering issues and should NOT be used"
        },
        {
            "trigger": "Sprite_IOflagNCM",
            "annotation": "Turns on NCM for this sprite<br><br> NOTE: It is best to use NCM where possible as it takes half the processing time per visible sprite on a Layer_Update, less chars on a line, and less memory for the image data at the cost of dropping to 16 colors",
            "kind": "snippet",
            "details": "Turns on NCM for this sprite<br><br> NOTE: It is best to use NCM where possible as it takes half the processing time per visible sprite on a Layer_Update, less chars on a line, and less memory for the image data at the cost of dropping to 16 colors"
        },
        {
            "trigger": "Sprite_IOflagOneShot",
            "annotation": "Starts as zero sets to 1 when the first animation loop has passed",
            "kind": "snippet",
            "details": "Starts as zero sets to 1 when the first animation loop has passed"
        },
        {
            "trigger": "Sprite_IOflags",
            "annotation": "Flags for the state of this sprite  bit 7 = Flip V (Not yet implemented) bit 6 = Flip H bit 5 = Enabled bit 0 = One shot flag",
            "kind": "snippet",
            "details": "Flags for the state of this sprite  bit 7 = Flip V (Not yet implemented) bit 6 = Flip H bit 5 = Enabled bit 0 = One shot flag"
        },
        {
            "trigger": "Sprite_IOflipHoffset",
            "annotation": "This registers is set internally on creation of a sprite and should NOT be manually changed",
            "kind": "snippet",
            "details": "This registers is set internally on creation of a sprite and should NOT be manually changed"
        },
        {
            "trigger": "Sprite_IOflipVoffset",
            "annotation": "This registers is set internally on creation of a sprite and should NOT be manually changed",
            "kind": "snippet",
            "details": "This registers is set internally on creation of a sprite and should NOT be manually changed"
        },
        {
            "trigger": "Sprite_IOheight",
            "annotation": "The height in chars for this sprite, sprites will automatically advance through the char set as they are drawn in pieces, top to bottom, left to right.",
            "kind": "snippet",
            "details": "The height in chars for this sprite, sprites will automatically advance through the char set as they are drawn in pieces, top to bottom, left to right."
        },
        {
            "trigger": "Sprite_IOptr",
            "annotation": "The IO register offset for looking up the sprite pointer location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address.",
            "kind": "snippet",
            "details": "The IO register offset for looking up the sprite pointer location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address."
        },
        {
            "trigger": "Sprite_IOwidth",
            "annotation": "The width in chars for this sprite, sprites will automatically advance through the char set as they are drawn in pieces, top to bottom, left to right.",
            "kind": "snippet",
            "details": "The width in chars for this sprite, sprites will automatically advance through the char set as they are drawn in pieces, top to bottom, left to right."
        },
        {
            "trigger": "Sprite_IOx",
            "annotation": "The IO register offset for looking up the a sprites x position location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address.",
            "kind": "snippet",
            "details": "The IO register offset for looking up the a sprites x position location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address."
        },
        {
            "trigger": "Sprite_IOy",
            "annotation": "The IO register offset for looking up the a sprites y position location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address.",
            "kind": "snippet",
            "details": "The IO register offset for looking up the a sprites y position location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address."
        },
        {
            "trigger": "Sprite_SpriteIOLength",
            "annotation": "The size in bytes of the IO registers for a single sprite",
            "kind": "snippet",
            "details": "The size in bytes of the IO registers for a single sprite"
        },
        {
            "trigger": "System_Compare16",
            "annotation": "valueA:valueB",
            "contents": "System_Compare16 ${1:valueA} : ${2:valueB}",
            "kind": "snippet",
            "details": "peforms a 16bit compare between value A and valueB, setting flags accordingly"
        },
        {
            "trigger": "System_GetRandom16",
            "annotation": "",
            "contents": "System_GetRandom16 ",
            "kind": "snippet",
            "details": "Returns a random 16 bit number in <a href=\"#Global_ReturnValue\">S65_ReturnValue</a><br> Accumulator will have the hi byte"
        },
        {
            "trigger": "System_GetRandom8",
            "annotation": "",
            "contents": "System_GetRandom8 ",
            "kind": "snippet",
            "details": "Returns a random 8 bit number in <a href=\"#Global_ReturnValue\">S65_ReturnValue</a> and the accumulator"
        },
        {
            "trigger": "System_HideScreen",
            "annotation": "",
            "contents": "System_HideScreen ",
            "kind": "snippet",
            "details": "Hides the display by setting illegal values in $d011. Useful for blacking out screen when loading from SDCard"
        },
        {
            "trigger": "System_SeedRandom16",
            "annotation": "seed",
            "contents": "System_SeedRandom16 ${1:seed}",
            "kind": "snippet",
            "details": "Seeds the random number generator using a 16bit non zero value. Passing a register will use that byute for both LSB and MSB"
        },
        {
            "trigger": "System_ShowScreen",
            "annotation": "",
            "contents": "System_ShowScreen ",
            "kind": "snippet",
            "details": "Shows the display after a HideScreen by setting valid values in $d011. Useful for blacking out screen when loading from SDCard"
        },
        {
            "trigger": "System_BasicUpstart65",
            "annotation": "addr",
            "contents": "System_BasicUpstart65(${1:addr})",
            "kind": "snippet",
            "details": "Creates the <a href='#System_BasicUpstart65_Format'>Basic Upstart</a> for the MEGA65 at location $2001 pointing to the given SYS entry address"
        },
        {
            "trigger": "System_BorderDebug",
            "annotation": "color",
            "contents": "System_BorderDebug(${1:color})",
            "kind": "snippet",
            "details": "If the preprocessor #define NODEBUG is not defined this will set the border color to the give value. Useful for debugging"
        },
        {
            "trigger": "System_DisableC65ROM",
            "annotation": "",
            "contents": "System_DisableC65ROM()",
            "kind": "snippet",
            "details": "Disables the C65 rom protection making it writable"
        },
        {
            "trigger": "System_Enable40Mhz",
            "annotation": "",
            "contents": "System_Enable40Mhz()",
            "kind": "snippet",
            "details": "Switches the MEGA65 45GS_02 processor to use 40.5Mhz mode"
        },
        {
            "trigger": "System_EnableFastRRB",
            "annotation": "",
            "contents": "System_EnableFastRRB()",
            "kind": "snippet",
            "details": "Enables rewrite double buffering to prevent clipping on the left side of the screen and enable 2 raster scans per line for double pixel clock in V200 mode."
        },
        {
            "trigger": "System_EnableVIC4",
            "annotation": "",
            "contents": "System_EnableVIC4()",
            "kind": "snippet",
            "details": "Switches the VIC chip in the MEGA65 into VIC4 mode."
        },
        {
            "trigger": "System_WaitForRaster",
            "annotation": "raster",
            "contents": "System_WaitForRaster(${1:raster})",
            "kind": "snippet",
            "details": "Halts execution and waits for the given raster line"
        },
        {
            "trigger": "System_BasicUpstart65_Format",
            "annotation": "",
            "kind": "snippet",
            "details": ""
        },
        {
            "trigger": "Tilemap_Draw",
            "annotation": "srcX:srcY:srcWidth:srcHeight",
            "contents": "Tilemap_Draw ${1:srcX} : ${2:srcY} : ${3:srcWidth} : ${4:srcHeight}",
            "kind": "snippet",
            "details": "Draws a rectangle from the currently active tilemap to the currently active layer using the current screenpointers<br> NOTE: that this routine will NOT wrap at the edge of the later so make sure to not ewxceed the layers right edge or you may cause RRB corruption"
        },
        {
            "trigger": "Tilemap_Get",
            "annotation": "tilemapId",
            "contents": "Tilemap_Get ${1:tilemapId}",
            "kind": "snippet",
            "details": "This method sets the currently active tilemap for all tilemap commands.<br><br> Note: This method will also call <a href=\"#S65_SetBasePage\">S65_SetBasePage</a> which is required for the Tilemap functions"
        },
        {
            "trigger": "Tilemap_TilemapData",
            "annotation": "Start of the tables for the Tilemap meta data",
            "kind": "snippet",
            "details": "Start of the tables for the Tilemap meta data"
        }
    ]
}