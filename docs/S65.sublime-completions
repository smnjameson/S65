{
    "scope": "source.assembly.kickassembler",
    "completions": [
        {
            "trigger": "S65_AddToMemoryReport",
            "annotation": "name",
            "contents": "S65_AddToMemoryReport(${1:name})",
            "kind": "snippet",
            "details": "Measures the byte size of a block of assembly and records it in the memory report output by <a href=\"#Global_MemoryReport\">S65_MemoryReport</a><br><br> Called at the start and the end of the code block you wish to measure by passing the same name in both"
        },
        {
            "trigger": "S65_MemoryReport",
            "annotation": "",
            "contents": "S65_MemoryReport()",
            "kind": "snippet",
            "details": "Called at the very end of your program code this macro will produce a report of the memory used in each of the framework calls"
        },
        {
            "trigger": "S65_RestoreBasePage",
            "annotation": "",
            "contents": "S65_RestoreBasePage()",
            "kind": "snippet",
            "details": "Restores the base page from S65_LastBasePage"
        },
        {
            "trigger": "S65_RestoreRegisters",
            "annotation": "",
            "contents": "S65_RestoreRegisters()",
            "kind": "snippet",
            "details": "Pulls the AXYZ registers off the stack"
        },
        {
            "trigger": "S65_SaveRegisters",
            "annotation": "",
            "contents": "S65_SaveRegisters()",
            "kind": "snippet",
            "details": "Pushes the AXYZ registers onto the stack"
        },
        {
            "trigger": "S65_SetBasePage",
            "annotation": "",
            "contents": "S65_SetBasePage()",
            "kind": "snippet",
            "details": "Saves the current base page in S65_LastBasePage and sets the base page to the S65 Base page area"
        },
        {
            "trigger": "S65_Text16",
            "annotation": "str",
            "contents": "S65_Text16(${1:str})",
            "kind": "snippet",
            "details": "Generates a string of 16 bit words based on the text input. The upper nybblwe of each word is $00 and the lower nybble is the normal 8 bit .screencode encoded value. terminates the string with $ffff"
        },
        {
            "trigger": "S65_Trace",
            "annotation": "str",
            "contents": "S65_Trace(${1:str})",
            "kind": "snippet",
            "details": "Outputs a string to the kick assembler console at build time"
        },
        {
            "trigger": "S65_COLOR_RAM",
            "annotation": "Defaults to $ff80000",
            "kind": "snippet",
            "details": "Defaults to $ff80000"
        },
        {
            "trigger": "S65_ColorRamPointer",
            "annotation": "S65 BasePage pointer into color ram. It is guaranteed to have the upper two bytes set at all times so can be used to access the color ram using 32bit indirect z addressing. DO NOT change bytes 2 and 3!<br><br> Note: Requires <a href=\"#Global_SetBasePage\">S65_SetBasePage</a> or <a href=\"#Layer_SetScreenPointersXY\">Layer_SetScreenPointersXY</a> to correctly set up the base page before using indirect indexed adressing modes.",
            "kind": "snippet",
            "details": "S65 BasePage pointer into color ram. It is guaranteed to have the upper two bytes set at all times so can be used to access the color ram using 32bit indirect z addressing. DO NOT change bytes 2 and 3!<br><br> Note: Requires <a href=\"#Global_SetBasePage\">S65_SetBasePage</a> or <a href=\"#Layer_SetScreenPointersXY\">Layer_SetScreenPointersXY</a> to correctly set up the base page before using indirect indexed adressing modes."
        },
        {
            "trigger": "S65_SCREEN_LOGICAL_ROW_WIDTH",
            "annotation": "Number of bytes that make up an entire screen row",
            "kind": "snippet",
            "details": "Number of bytes that make up an entire screen row"
        },
        {
            "trigger": "S65_SCREEN_RAM",
            "annotation": "Defaults to $0800",
            "kind": "snippet",
            "details": "Defaults to $0800"
        },
        {
            "trigger": "S65_SCREEN_ROW_WIDTH",
            "annotation": "Number of characters that make up an entire screen row",
            "kind": "snippet",
            "details": "Number of characters that make up an entire screen row"
        },
        {
            "trigger": "S65_SCREEN_TERMINATOR_OFFSET",
            "annotation": "Screen row offset for the row terminator bytes",
            "kind": "snippet",
            "details": "Screen row offset for the row terminator bytes"
        },
        {
            "trigger": "S65_ScreenRamPointer",
            "annotation": "S65 BasePage pointer into screen ram. It is guaranteed to have the upper two bytes set at all times so can be used to access the screen ram using 32bit indirect z addressing. DO NOT change bytes 2 and 3!<br><br>  For this reason you MUST use a Screen RAM location that does not cross a 64kb boundary and aligned to page boundarys as the engine assumes this for speed<br><br>  Note: Requires <a href=\"#Global_SetBasePage\">S65_SetBasePage</a> or <a href=\"#Layer_SetScreenPointersXY\">Layer_SetScreenPointersXY</a> to correctly set up the base page before using indirect indexed adressing modes.",
            "kind": "snippet",
            "details": "S65 BasePage pointer into screen ram. It is guaranteed to have the upper two bytes set at all times so can be used to access the screen ram using 32bit indirect z addressing. DO NOT change bytes 2 and 3!<br><br>  For this reason you MUST use a Screen RAM location that does not cross a 64kb boundary and aligned to page boundarys as the engine assumes this for speed<br><br>  Note: Requires <a href=\"#Global_SetBasePage\">S65_SetBasePage</a> or <a href=\"#Layer_SetScreenPointersXY\">Layer_SetScreenPointersXY</a> to correctly set up the base page before using indirect indexed adressing modes."
        },
        {
            "trigger": "S65_SpareBasePage",
            "annotation": "16 bytes of spare storage free for use when the S65 base page is active to assist with using commands that expect to be in base page",
            "kind": "snippet",
            "details": "16 bytes of spare storage free for use when the S65 base page is active to assist with using commands that expect to be in base page"
        },
        {
            "trigger": "S65_VISIBLE_SCREEN_CHAR_HEIGHT",
            "annotation": "Height of the visible screen background layer in characters",
            "kind": "snippet",
            "details": "Height of the visible screen background layer in characters"
        },
        {
            "trigger": "S65_VISIBLE_SCREEN_CHAR_WIDTH",
            "annotation": "Width of the visible screen background layer in characters",
            "kind": "snippet",
            "details": "Width of the visible screen background layer in characters"
        },
        {
            "trigger": "DMA_CopyJob",
            "annotation": "source:destination:length:chain:Destination",
            "contents": "DMA_CopyJob ${1:source} : ${2:destination} : ${3:length} : ${4:chain} : ${5:Destination}",
            "kind": "snippet",
            "details": "Copys a defined number of bytes from one location in memory to another using the DMagic chip @ 20mb/s"
        },
        {
            "trigger": "DMA_DisableTransparency",
            "annotation": "",
            "contents": "DMA_DisableTransparency ",
            "kind": "snippet",
            "details": "Disables any transparent byte masking. This is the default state."
        },
        {
            "trigger": "DMA_EnableTransparency",
            "annotation": "transparentByte",
            "contents": "DMA_EnableTransparency ${1:transparentByte}",
            "kind": "snippet",
            "details": "Enables transparent byte masking. This will ignore any source bytes that match the given byte and leave the destination byte untouched."
        },
        {
            "trigger": "DMA_Execute",
            "annotation": "address",
            "contents": "DMA_Execute ${1:address}",
            "kind": "snippet",
            "details": "Executes the DMagic job at the given address."
        },
        {
            "trigger": "DMA_FillJob",
            "annotation": "sourceByte:destination:length:chain",
            "contents": "DMA_FillJob ${1:sourceByte} : ${2:destination} : ${3:length} : ${4:chain}",
            "kind": "snippet",
            "details": "Fills a defined number of bytes from one location in memory to another using the DMagic chip @ 40mb/s"
        },
        {
            "trigger": "DMA_Header",
            "annotation": "sourceBank:destBank",
            "contents": "DMA_Header ${1:sourceBank} : ${2:destBank}",
            "kind": "snippet",
            "details": "Sets the DMagic header bytes defining the source and destination banks.<br><br> Note: The bank number of a memory adress is its 5th and 6th nybble. e.g. $ff80000 is bank number $ff"
        },
        {
            "trigger": "DMA_Step",
            "annotation": "sourceStep:destStep",
            "contents": "DMA_Step ${1:sourceStep} : ${2:destStep}",
            "kind": "snippet",
            "details": "Sets the source and/or destination stepping values. The DMA will use a fixed point step for each increment on the source and destination by default they are both set to the fixed point 8:8 value $0100 (or 1.0 in decimal)"
        },
        {
            "trigger": "DMA_F018_DMA_11_byte_format",
            "annotation": "Offsets into the DMagic job for the <a target=\"_blank\" href=\"#https://files.mega65.org/manuals-upload/mega65-chipset-reference.pdf#F018%20DMA%20Job%20List%20Format\">F018 11 byte data format</a>.",
            "kind": "snippet",
            "details": "Offsets into the DMagic job for the <a target=\"_blank\" href=\"#https://files.mega65.org/manuals-upload/mega65-chipset-reference.pdf#F018%20DMA%20Job%20List%20Format\">F018 11 byte data format</a>."
        },
        {
            "trigger": "Layer_AddText",
            "annotation": "layer:xpos:ypos:textPtr:color",
            "contents": "Layer_AddText ${1:layer} : ${2:xpos} : ${3:ypos} : ${4:textPtr} : ${5:color}",
            "kind": "snippet",
            "details": "Writes a string of bytes to the given layer and co-ordinate. Optionally allows the use of color, setting Color RAM Byte 1 all bits (so includes bit4-blink, bit5-reverse, bit6-bold and bit7-underline), this will only work on non NCM layers with char indices less than $100 <br><br>  Note: As layer screen rows are interlaced in memory, its important to not let the string extend off the right edge of the layer as it can break the RRB on other layers. There is an upper limit string length of 128"
        },
        {
            "trigger": "Layer_AdvanceScreenPointers",
            "annotation": "Optional",
            "contents": "Layer_AdvanceScreenPointers ${1:Optional}",
            "kind": "snippet",
            "details": "Advances the S65 Basepage dword values for <a href=\"#Global_ColorRamPointer\">ColorRamPointer<a> and <a href=\"#Global_ScreenRamPointer\">ScreenRamPointer<a> by the given byte offset.<br><br>  Note: This method assumes you are already in the S65 base page, this is true after a <a href=\"#Layer_SetScreenPointersXY\">Layer_SetScreenPointersXY</a> command, be careful not to use this command if base page is not set, otherwise it will likely write to unintended locations"
        },
        {
            "trigger": "Layer_ClearAllLayers",
            "annotation": "clearChar",
            "contents": "Layer_ClearAllLayers ${1:clearChar}",
            "kind": "snippet",
            "details": "Fills the screen RAM area with a given 16bit value. Note this will overwrite any RRB GotoX markers also"
        },
        {
            "trigger": "Layer_ClearLayer",
            "annotation": "layer:clearChar:clearColor",
            "contents": "Layer_ClearLayer ${1:layer} : ${2:clearChar} : ${3:clearColor}",
            "kind": "snippet",
            "details": "Fills the screen RAM area for the layer with a given 16bit value."
        },
        {
            "trigger": "Layer_SetScreenPointersXY",
            "annotation": "layer:xpos:ypos",
            "contents": "Layer_SetScreenPointersXY ${1:layer} : ${2:xpos} : ${3:ypos}",
            "kind": "snippet",
            "details": "Sets the basepage to point to the S65 base page area and then sets screen and color ram pointers <a href=\"#Global_ScreenRamPointer\">ScreenRamPointer<a> and <a href=\"#Global_ColorRamPointer\">ColorRamPointer<a> to point to the given layers x and y co-ordinate"
        },
        {
            "trigger": "Layer_Update",
            "annotation": "",
            "contents": "Layer_Update ",
            "kind": "snippet",
            "details": "Updates the all the layers Note: this is an expensive operation in both memory and cpu, try to call it once only per frame and put it in a subroutine if you need to call it from more than one place"
        },
        {
            "trigger": "Layer_WriteToScreen",
            "annotation": "screenSource:colorSource:size",
            "contents": "Layer_WriteToScreen ${1:screenSource} : ${2:colorSource} : ${3:size}",
            "kind": "snippet",
            "details": "Copys up to 256 bytes from the source addresses to the locations pointed at by <a href=\"#Global_ScreenRamPointer\">ScreenRamPointer<a> and optionally <a href=\"#Global_ColorRamPointer\">ColorRamPointer<a>. Does NOT change the contents of the screen and color ram pointers.<br> If immediate values are used for source then this byte is written directly<br><br> Note: This method assumes you are already in the S65 base page, this is true after a <a href=\"#Layer_SetScreenPointersXY\">Layer_SetScreenPointersXY</a> command, be careful not to use this command if base page is not set, otherwise it will likely write to unintended locations<br> If ABSY mode is used for either source then the y register is added to the address before writing. Additionally upon completion the Y register will be incremented by the amount of bytes written<br><br> Note: Writing past the end of your layers right edge can cause RRB and memory issues please use <a href=\"#Layer_AdvanceScreenPointers\">Layer_AdvanceScreenPointers<a> to move the pointers safely to the next row"
        },
        {
            "trigger": "Layer_DefineRRBSpriteLayer",
            "annotation": "charsPerLine,maxSprites",
            "contents": "Layer_DefineRRBSpriteLayer(${1:charsPerLine}, ${2:maxSprites})",
            "kind": "snippet",
            "details": "Defines a new RRB Sprite layer in Screen RAM. RRB Sprite layers are always NCM mode (16x8px chars). IO for this layer is assigned to the Layer IO dynamic memory area<br> Note that chars per line is NOT the max sprites per line as a sprite can be any multiple of 16 chars wide<br><br>   RRB Sprite space is a buffer limited by a set amount of chars per line. During an update each new Sprite uses a GOTOX marker and however many RRB chars wide it is. So, for example, a 32x32 RRB sprite is 2 chars wide + a GOTOX marker so will take 3 chars of space.<br><br> Note: There is a RRB Sprite hard limit of 256 per RRB Sprite layer.  The majority of the memory and cpu time consumed by the RRB Sprite system is a result of the number of maxSprites. Reducing this number will have the best impact on SpriteIO area memory usage as each sprite slot (regardless if its enabled or not in <a href=\"#Sprite_IOflags\">Sprite_IOflags</a>will use at least 10 bytes each. And every sprite that IS enabled will use some cpu time to update."
        },
        {
            "trigger": "Layer_DefineResolution",
            "annotation": "charWidth,charHeight,stretchWide",
            "contents": "Layer_DefineResolution(${1:charWidth}, ${2:charHeight}, ${3:stretchWide})",
            "kind": "snippet",
            "details": "Defines the screen resolution in 8x8 charachters (regardless if NCM is being used) and if it should be stretched horizontally to fit the width of the display. <a href=\"##Layer_InitScreen\">Layer_InitScreen</a> will configure the borders and TEXTXPOS and TEXTYPOS to center the screen on the display.<br><br>  NOTE:<br> - charHeight above 32 will use V400 mode and disable any RRB double buffering and double rate RRB<br> - charWidth above 42 will use H640 mode<br>"
        },
        {
            "trigger": "Layer_DefineScreenLayer",
            "annotation": "charWidth,offsetX,ncm",
            "contents": "Layer_DefineScreenLayer(${1:charWidth}, ${2:offsetX}, ${3:ncm})",
            "kind": "snippet",
            "details": "Defines a new screen layer in Screen RAM optionally shifting its RRB GOTOX offset.<br> Note: the maximum charWidth for a layer is 126"
        },
        {
            "trigger": "Layer_InitScreen",
            "annotation": "screenBaseAddress",
            "contents": "Layer_InitScreen(${1:screenBaseAddress})",
            "kind": "snippet",
            "details": "Initialises the MEGA65 and VIC-IV and parses the Layer definitions into a Screen RAM layout"
        },
        {
            "trigger": "Layer_GetColorAddress",
            "annotation": "layerNumber,xpos,ypos",
            "contents": "Layer_GetColorAddress(${1:layerNumber}, ${2:xpos}, ${3:ypos})",
            "kind": "snippet",
            "details": "Returns the address of the color RAM at the given position on this screen layer"
        },
        {
            "trigger": "Layer_GetIO",
            "annotation": "layerNumber,register",
            "contents": "Layer_GetIO(${1:layerNumber}, ${2:register})",
            "kind": "snippet",
            "details": "Returns the base address for the given layer & register.<br> See <a href='#Layer_Vars'>Layer_IO<a> for register list"
        },
        {
            "trigger": "Layer_GetLayerCount",
            "annotation": "",
            "contents": "Layer_GetLayerCount()",
            "kind": "snippet",
            "details": "Returns the current number of layers, useful for assigning to constants to name each layer for use in your code."
        },
        {
            "trigger": "Layer_GetScreenAddress",
            "annotation": "layerNumber,xpos,ypos",
            "contents": "Layer_GetScreenAddress(${1:layerNumber}, ${2:xpos}, ${3:ypos})",
            "kind": "snippet",
            "details": "Returns the address of the char at the given position on this screen layer"
        },
        {
            "trigger": "Layer_GotoXColorPositions",
            "annotation": "Table of GOTOX Attribute in color ram for each layer",
            "kind": "snippet",
            "details": "Table of GOTOX Attribute in color ram for each layer"
        },
        {
            "trigger": "Layer_GotoXPositions",
            "annotation": "Table of current GOTOX positions for all the layers",
            "kind": "snippet",
            "details": "Table of current GOTOX positions for all the layers"
        },
        {
            "trigger": "Layer_LayerWidth",
            "annotation": "Table of start address offsets for each layer",
            "kind": "snippet",
            "details": "Table of start address offsets for each layer"
        },
        {
            "trigger": "Layer_LogicalWidth",
            "annotation": "Contains the current Screen Row Logical Width in bytes",
            "kind": "snippet",
            "details": "Contains the current Screen Row Logical Width in bytes"
        },
        {
            "trigger": "Layer_AddrOffsets",
            "annotation": "Pointer to Table of start address offsets for each layer",
            "kind": "snippet",
            "details": "Pointer to Table of start address offsets for each layer"
        },
        {
            "trigger": "Layer_DMAClear",
            "annotation": "Pointer to a dma subroutine that clears the screen ram layer, A=layer, X=charLo, Y=charHi",
            "kind": "snippet",
            "details": "Pointer to a dma subroutine that clears the screen ram layer, A=layer, X=charLo, Y=charHi"
        },
        {
            "trigger": "Layer_DMAClearColor",
            "annotation": "Pointer to a dma subroutine that clears the color ram layer, A=layer, X=color",
            "kind": "snippet",
            "details": "Pointer to a dma subroutine that clears the color ram layer, A=layer, X=color"
        },
        {
            "trigger": "Layer_DMAClearColorRRB",
            "annotation": "Pointer to a dma subroutine that clears the color ram layer for RRB sprites, A=layer",
            "kind": "snippet",
            "details": "Pointer to a dma subroutine that clears the color ram layer for RRB sprites, A=layer"
        },
        {
            "trigger": "Layer_DynamicDataTable",
            "annotation": "A pointer to the table containing the address of each layers dynamic data, this memory is initialised on a <a href='#Layer_InitScreen'>Layer_InitScreen</a> it's size is dependant on the screen layer structure, RRB sprite layers use the most memory",
            "kind": "snippet",
            "details": "A pointer to the table containing the address of each layers dynamic data, this memory is initialised on a <a href='#Layer_InitScreen'>Layer_InitScreen</a> it's size is dependant on the screen layer structure, RRB sprite layers use the most memory"
        },
        {
            "trigger": "Layer_IOgotoX",
            "annotation": "The IO register index for this layers GOTOX value. Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function.",
            "kind": "snippet",
            "details": "The IO register index for this layers GOTOX value. Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function."
        },
        {
            "trigger": "Layer_IOmaxCharsRRB",
            "annotation": "RRB SPRITE LAYER ONLY. The IO register index for this layers maximum chars per line value. <br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function.",
            "kind": "snippet",
            "details": "RRB SPRITE LAYER ONLY. The IO register index for this layers maximum chars per line value. <br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function."
        },
        {
            "trigger": "Layer_IOmaxSpritesRRB",
            "annotation": "RRB SPRITE LAYER ONLY. The IO register index for this layers maximum sprites value.<br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function.",
            "kind": "snippet",
            "details": "RRB SPRITE LAYER ONLY. The IO register index for this layers maximum sprites value.<br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function."
        },
        {
            "trigger": "Layer_IOrowCountTableRRB",
            "annotation": "RRB SPRITE LAYER ONLY. The IO register index for this layers RRB sprite rowCharCount table, used internally by the RRB sprite system.<br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function.",
            "kind": "snippet",
            "details": "RRB SPRITE LAYER ONLY. The IO register index for this layers RRB sprite rowCharCount table, used internally by the RRB sprite system.<br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function."
        },
        {
            "trigger": "Layer_IsRRBSprite",
            "annotation": "Pointer to the table of flags indicating if layers are RRB sprite layer",
            "kind": "snippet",
            "details": "Pointer to the table of flags indicating if layers are RRB sprite layer"
        },
        {
            "trigger": "Layer_RowAddressBaseLSB",
            "annotation": "Pointer to the table of LSB values for the address of the start of each screen row directly",
            "kind": "snippet",
            "details": "Pointer to the table of LSB values for the address of the start of each screen row directly"
        },
        {
            "trigger": "Layer_RowAddressBaseMSB",
            "annotation": "Pointer to the table of MSB values for the address of the start of each screen row directly",
            "kind": "snippet",
            "details": "Pointer to the table of MSB values for the address of the start of each screen row directly"
        },
        {
            "trigger": "Layer_RowAddressLSB",
            "annotation": "Pointer to the table of LSB values for the address of the start of each screen row directly after the first GOTOX",
            "kind": "snippet",
            "details": "Pointer to the table of LSB values for the address of the start of each screen row directly after the first GOTOX"
        },
        {
            "trigger": "Layer_RowAddressMSB",
            "annotation": "Pointer to the table of MSB values for the address of the start of each screen row directly after the first GOTOX",
            "kind": "snippet",
            "details": "Pointer to the table of MSB values for the address of the start of each screen row directly after the first GOTOX"
        },
        {
            "trigger": "Layer_SpriteIOAddrLSB",
            "annotation": "Pointer to the table of LSB values for the address of the start of the layers sprite IO area",
            "kind": "snippet",
            "details": "Pointer to the table of LSB values for the address of the start of the layers sprite IO area"
        },
        {
            "trigger": "Layer_SpriteIOAddrMSB",
            "annotation": "Pointer to the table of MSB values for the address of the start of the layers sprite IO area",
            "kind": "snippet",
            "details": "Pointer to the table of MSB values for the address of the start of the layers sprite IO area"
        },
        {
            "trigger": "Palette_LoadFromMem",
            "annotation": "paletteNum:addr:size",
            "contents": "Palette_LoadFromMem ${1:paletteNum} : ${2:addr} : ${3:size}",
            "kind": "snippet",
            "details": "Copys data from agiven address into one of the MEGA65 palettes. The palette will remain the active mapped palette at $d100"
        },
        {
            "trigger": "Palette_LoadFromSD",
            "annotation": "paletteNum:addr",
            "contents": "Palette_LoadFromSD ${1:paletteNum} : ${2:addr}",
            "kind": "snippet",
            "details": "Loads a full 256 color palette from SD card"
        },
        {
            "trigger": "Palette_Map",
            "annotation": "paletteNum",
            "contents": "Palette_Map ${1:paletteNum}",
            "kind": "snippet",
            "details": "Maps a palette into IO memory"
        },
        {
            "trigger": "Palette_SetPalettes",
            "annotation": "palleteChar:paletteSprite:paletteAltChar",
            "contents": "Palette_SetPalettes ${1:palleteChar} : ${2:paletteSprite} : ${3:paletteAltChar}",
            "kind": "snippet",
            "details": "Assigns palettes to the MEGA65 palette banks."
        },
        {
            "trigger": "Palette_MEGA65_Palette",
            "annotation": "The MEGA65 has up to 4 palettes that can be assigned to the various graphic types Sprite and Character. At any one time one of the palettes will be banked into IO memory at $d100-$d3ff.  Note: While the palette format is RGB788 the nybbles of each byte are switched e.g. $F0 becomes $0F, to maintain compatibility with the C65",
            "kind": "snippet",
            "details": "The MEGA65 has up to 4 palettes that can be assigned to the various graphic types Sprite and Character. At any one time one of the palettes will be banked into IO memory at $d100-$d3ff.  Note: While the palette format is RGB788 the nybbles of each byte are switched e.g. $F0 becomes $0F, to maintain compatibility with the C65"
        },
        {
            "trigger": "Palette_0",
            "annotation": "MEGA65 palette 0",
            "kind": "snippet",
            "details": "MEGA65 palette 0"
        },
        {
            "trigger": "Palette_1",
            "annotation": "MEGA65 palette 1",
            "kind": "snippet",
            "details": "MEGA65 palette 1"
        },
        {
            "trigger": "Palette_2",
            "annotation": "MEGA65 palette 2",
            "kind": "snippet",
            "details": "MEGA65 palette 2"
        },
        {
            "trigger": "Palette_3",
            "annotation": "MEGA65 palette 3",
            "kind": "snippet",
            "details": "MEGA65 palette 3"
        },
        {
            "trigger": "SDCard_LoadToAtticRam",
            "annotation": "addr:filePtr",
            "contents": "SDCard_LoadToAtticRam ${1:addr} : ${2:filePtr}",
            "kind": "snippet",
            "details": "Loads a file from the SDCard into attic RAM"
        },
        {
            "trigger": "SDCard_LoadToChipRam",
            "annotation": "addr:filePtr",
            "contents": "SDCard_LoadToChipRam ${1:addr} : ${2:filePtr}",
            "kind": "snippet",
            "details": "Loads a file from the SDCard into chip RAM"
        },
        {
            "trigger": "Sprite_Update",
            "annotation": "",
            "contents": "Sprite_Update ",
            "kind": "snippet",
            "details": ""
        },
        {
            "trigger": "Sprite_GenerateLayerData",
            "annotation": "",
            "contents": "Sprite_GenerateLayerData()",
            "kind": "snippet",
            "details": ""
        },
        {
            "trigger": "Sprite_GetIO",
            "annotation": "layerNumber,spriteNumber,register",
            "contents": "Sprite_GetIO(${1:layerNumber}, ${2:spriteNumber}, ${3:register})",
            "kind": "snippet",
            "details": "Returns the base address for the given layer & IO register.<br> See <a href='#Sprite_Vars'>Sprite_IO<a> for register list"
        },
        {
            "trigger": "Sprite_IOcolor",
            "annotation": "The color to apply to all the cahrs in this sprite",
            "kind": "snippet",
            "details": "The color to apply to all the cahrs in this sprite"
        },
        {
            "trigger": "Sprite_IOflags",
            "annotation": "Flags for the state of this sprite  bit 7 = Enabled bit 6 = Flip H (Not yet implemented) bit 5 = Flip V (Not yet implemented)",
            "kind": "snippet",
            "details": "Flags for the state of this sprite  bit 7 = Enabled bit 6 = Flip H (Not yet implemented) bit 5 = Flip V (Not yet implemented)"
        },
        {
            "trigger": "Sprite_IOheight",
            "annotation": "The height in chars for this sprite, sprites will automatically advance through the char set as they are drawn in pieces, top to bottom, left to right.",
            "kind": "snippet",
            "details": "The height in chars for this sprite, sprites will automatically advance through the char set as they are drawn in pieces, top to bottom, left to right."
        },
        {
            "trigger": "Sprite_IOptr",
            "annotation": "The IO register offset for looking up the sprite pointer location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address.",
            "kind": "snippet",
            "details": "The IO register offset for looking up the sprite pointer location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address."
        },
        {
            "trigger": "Sprite_IOwidth",
            "annotation": "The width in chars for this sprite, sprites will automatically advance through the char set as they are drawn in pieces, top to bottom, left to right.",
            "kind": "snippet",
            "details": "The width in chars for this sprite, sprites will automatically advance through the char set as they are drawn in pieces, top to bottom, left to right."
        },
        {
            "trigger": "Sprite_IOx",
            "annotation": "The IO register offset for looking up the a sprites x position location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address.",
            "kind": "snippet",
            "details": "The IO register offset for looking up the a sprites x position location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address."
        },
        {
            "trigger": "Sprite_IOy",
            "annotation": "The IO register offset for looking up the a sprites y position location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address.",
            "kind": "snippet",
            "details": "The IO register offset for looking up the a sprites y position location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address."
        },
        {
            "trigger": "Sprite_SpriteIOLength",
            "annotation": "The size in bytes of the IO registers for a single sprite",
            "kind": "snippet",
            "details": "The size in bytes of the IO registers for a single sprite"
        },
        {
            "trigger": "System_BasicUpstart65",
            "annotation": "addr",
            "contents": "System_BasicUpstart65(${1:addr})",
            "kind": "snippet",
            "details": "Creates the <a href='#System_BasicUpstart65_Format'>Basic Upstart</a> for the MEGA65 at location $2001 pointing to the given SYS entry address"
        },
        {
            "trigger": "System_BorderDebug",
            "annotation": "color",
            "contents": "System_BorderDebug(${1:color})",
            "kind": "snippet",
            "details": "If the preprocessor #define NODEBUG is not defined this will set the border color to the give value. Useful for debugging"
        },
        {
            "trigger": "System_DisableC65ROM",
            "annotation": "",
            "contents": "System_DisableC65ROM()",
            "kind": "snippet",
            "details": "Disables the C65 rom protection making it writable"
        },
        {
            "trigger": "System_Enable40Mhz",
            "annotation": "",
            "contents": "System_Enable40Mhz()",
            "kind": "snippet",
            "details": "Switches the MEGA65 45GS_02 processor to use 40.5Mhz mode"
        },
        {
            "trigger": "System_EnableFastRRB",
            "annotation": "",
            "contents": "System_EnableFastRRB()",
            "kind": "snippet",
            "details": "Enables rewrite double buffering to prevent clipping on the left side of the screen and enable 2 raster scans per line for double pixel clock in V200 mode."
        },
        {
            "trigger": "System_EnableVIC4",
            "annotation": "",
            "contents": "System_EnableVIC4()",
            "kind": "snippet",
            "details": "Switches the VIC chip in the MEGA65 into VIC4 mode."
        },
        {
            "trigger": "System_WaitForRaster",
            "annotation": "raster",
            "contents": "System_WaitForRaster(${1:raster})",
            "kind": "snippet",
            "details": "Halts execution and waits for the given raster line"
        },
        {
            "trigger": "System_BasicUpstart65_Format",
            "annotation": "",
            "kind": "snippet",
            "details": ""
        }
    ]
}