{
    "scope": "source.assembly.kickassembler",
    "completions": [
        {
            "trigger": "id",
            "annotation": "Asset_Spriteset",
            "kind": "snippet"
        },
        {
            "trigger": "name",
            "annotation": "Asset_Spriteset",
            "kind": "snippet"
        },
        {
            "trigger": "address",
            "annotation": "Asset_Spriteset",
            "kind": "snippet"
        },
        {
            "trigger": "metaAddress",
            "annotation": "Asset_Spriteset",
            "kind": "snippet"
        },
        {
            "trigger": "meta",
            "annotation": "Asset_Spriteset",
            "kind": "snippet"
        },
        {
            "trigger": "palette",
            "annotation": "Asset_Spriteset",
            "kind": "snippet"
        },
        {
            "trigger": "indices",
            "annotation": "Asset_Spriteset",
            "kind": "snippet"
        },
        {
            "trigger": "id",
            "annotation": "Asset_Charset",
            "kind": "snippet"
        },
        {
            "trigger": "name",
            "annotation": "Asset_Charset",
            "kind": "snippet"
        },
        {
            "trigger": "address",
            "annotation": "Asset_Charset",
            "kind": "snippet"
        },
        {
            "trigger": "colorAddress",
            "annotation": "Asset_Charset",
            "kind": "snippet"
        },
        {
            "trigger": "palette",
            "annotation": "Asset_Charset",
            "kind": "snippet"
        },
        {
            "trigger": "colors",
            "annotation": "Asset_Charset",
            "kind": "snippet"
        },
        {
            "trigger": "indices",
            "annotation": "Asset_Charset",
            "kind": "snippet"
        },
        {
            "trigger": "S65_AddToMemoryReport",
            "annotation": "name",
            "contents": "S65_AddToMemoryReport(${1:name})",
            "kind": "snippet",
            "details": "Measures the byte size of a block of assembly and records it in the memory report output by <a href=\"#Global_MemoryReport\">S65_MemoryReport</a><br><br> Called at the start and the end of the code block you wish to measure by passing the same name in both"
        },
        {
            "trigger": "S65_MemoryReport",
            "annotation": "",
            "contents": "S65_MemoryReport()",
            "kind": "snippet",
            "details": "Called at the very end of your program code this macro will produce a report of the memory used in each of the framework calls"
        },
        {
            "trigger": "S65_RestoreBasePage",
            "annotation": "",
            "contents": "S65_RestoreBasePage()",
            "kind": "snippet",
            "details": "Restores the base page from S65_LastBasePage"
        },
        {
            "trigger": "S65_RestoreRegisters",
            "annotation": "",
            "contents": "S65_RestoreRegisters()",
            "kind": "snippet",
            "details": "Pulls the AXYZ registers off the stack"
        },
        {
            "trigger": "S65_SaveRegisters",
            "annotation": "",
            "contents": "S65_SaveRegisters()",
            "kind": "snippet",
            "details": "Pushes the AXYZ registers onto the stack"
        },
        {
            "trigger": "S65_SetBasePage",
            "annotation": "",
            "contents": "S65_SetBasePage()",
            "kind": "snippet",
            "details": "Saves the current base page in S65_LastBasePage and sets the base page to the S65 Base page area"
        },
        {
            "trigger": "S65_Text16",
            "annotation": "str",
            "contents": "S65_Text16(${1:str})",
            "kind": "snippet",
            "details": "Generates a string of 16 bit words based on the text input. The upper nybblwe of each word is $00 and the lower nybble is the normal 8 bit .screencode encoded value. terminates the string with $ffff"
        },
        {
            "trigger": "S65_Trace",
            "annotation": "str",
            "contents": "S65_Trace(${1:str})",
            "kind": "snippet",
            "details": "Outputs a string to the kick assembler console at build time"
        },
        {
            "trigger": "S65_COLOR_RAM",
            "annotation": "Defaults to $ff80000",
            "kind": "snippet",
            "details": "Defaults to $ff80000"
        },
        {
            "trigger": "S65_ColorRamPointer",
            "annotation": "{dword} S65 BasePage pointer into color ram. It is guaranteed to have the upper two bytes set at all times so can be used to access the color ram using 32bit indirect z addressing. DO NOT change bytes 2 and 3!<br><br> Note: Requires <a href=\"#Global_SetBasePage\">S65_SetBasePage</a> or <a href=\"#Layer_SetScreenPointersXY\">Layer_SetScreenPointersXY</a> to correctly set up the base page before using indirect indexed adressing modes.",
            "kind": "snippet",
            "details": "{dword} S65 BasePage pointer into color ram. It is guaranteed to have the upper two bytes set at all times so can be used to access the color ram using 32bit indirect z addressing. DO NOT change bytes 2 and 3!<br><br> Note: Requires <a href=\"#Global_SetBasePage\">S65_SetBasePage</a> or <a href=\"#Layer_SetScreenPointersXY\">Layer_SetScreenPointersXY</a> to correctly set up the base page before using indirect indexed adressing modes."
        },
        {
            "trigger": "S65_LastImportPtr",
            "annotation": "Contains the address at which the last Asset_Import macro finished importing. Useful for chaining imports together",
            "kind": "snippet",
            "details": "Contains the address at which the last Asset_Import macro finished importing. Useful for chaining imports together"
        },
        {
            "trigger": "S65_LastLayerIOPointer",
            "annotation": "{word} S65 BasePage pointer into to the IO data for the last layer that was fetched using <a href=\"#Layer_Get\">Layer_Get</a>",
            "kind": "snippet",
            "details": "{word} S65 BasePage pointer into to the IO data for the last layer that was fetched using <a href=\"#Layer_Get\">Layer_Get</a>"
        },
        {
            "trigger": "S65_LastSpriteIOPointer",
            "annotation": "{word} S65 BasePage pointer into to the IO data for the last sprite that was fetched using <a href=\"#Sprite_Get\">Sprite_Get</a>",
            "kind": "snippet",
            "details": "{word} S65 BasePage pointer into to the IO data for the last sprite that was fetched using <a href=\"#Sprite_Get\">Sprite_Get</a>"
        },
        {
            "trigger": "S65_ReturnValue",
            "annotation": "{word} S65 BasePage value that is used as a return for many commands when the result is a word rather than a byte.",
            "kind": "snippet",
            "details": "{word} S65 BasePage value that is used as a return for many commands when the result is a word rather than a byte."
        },
        {
            "trigger": "S65_SCREEN_LOGICAL_ROW_WIDTH",
            "annotation": "Number of bytes that make up an entire screen row",
            "kind": "snippet",
            "details": "Number of bytes that make up an entire screen row"
        },
        {
            "trigger": "S65_SCREEN_RAM",
            "annotation": "Defaults to $0800",
            "kind": "snippet",
            "details": "Defaults to $0800"
        },
        {
            "trigger": "S65_SCREEN_ROW_WIDTH",
            "annotation": "Number of characters that make up an entire screen row",
            "kind": "snippet",
            "details": "Number of characters that make up an entire screen row"
        },
        {
            "trigger": "S65_SCREEN_TERMINATOR_OFFSET",
            "annotation": "Screen row offset for the row terminator bytes",
            "kind": "snippet",
            "details": "Screen row offset for the row terminator bytes"
        },
        {
            "trigger": "S65_ScreenRamPointer",
            "annotation": "{dword} S65 BasePage pointer into screen ram. It is guaranteed to have the upper two bytes set at all times so can be used to access the screen ram using 32bit indirect z addressing. DO NOT change bytes 2 and 3!<br><br>  For this reason you MUST use a Screen RAM location that does not cross a 64kb boundary and aligned to page boundarys as the engine assumes this for speed<br><br>  Note: Requires <a href=\"#Global_SetBasePage\">S65_SetBasePage</a> or <a href=\"#Layer_SetScreenPointersXY\">Layer_SetScreenPointersXY</a> to correctly set up the base page before using indirect indexed adressing modes.",
            "kind": "snippet",
            "details": "{dword} S65 BasePage pointer into screen ram. It is guaranteed to have the upper two bytes set at all times so can be used to access the screen ram using 32bit indirect z addressing. DO NOT change bytes 2 and 3!<br><br>  For this reason you MUST use a Screen RAM location that does not cross a 64kb boundary and aligned to page boundarys as the engine assumes this for speed<br><br>  Note: Requires <a href=\"#Global_SetBasePage\">S65_SetBasePage</a> or <a href=\"#Layer_SetScreenPointersXY\">Layer_SetScreenPointersXY</a> to correctly set up the base page before using indirect indexed adressing modes."
        },
        {
            "trigger": "S65_SpareBasePage",
            "annotation": "16 bytes of spare storage free for use when the S65 base page is active to assist with using commands that expect to be in S65 base page",
            "kind": "snippet",
            "details": "16 bytes of spare storage free for use when the S65 base page is active to assist with using commands that expect to be in S65 base page"
        },
        {
            "trigger": "S65_VISIBLE_SCREEN_CHAR_HEIGHT",
            "annotation": "Height of the visible screen background layer in characters",
            "kind": "snippet",
            "details": "Height of the visible screen background layer in characters"
        },
        {
            "trigger": "S65_VISIBLE_SCREEN_CHAR_WIDTH",
            "annotation": "Width of the visible screen background layer in characters",
            "kind": "snippet",
            "details": "Width of the visible screen background layer in characters"
        },
        {
            "trigger": "Asset_ImportCharset",
            "annotation": "name,charpath,address",
            "contents": "Asset_ImportCharset(${1:name}, ${2:charpath}, ${3:address})",
            "kind": "snippet",
            "details": "Helper function to preload the _chars file generated by png65 into a given address and load the _ncm file <br> When loading using these imports you only need the first part of the path and file name. eg<br><br> Asset_ImportCharset(\"map\",\"assets/bin/tileset1\", $8000)<br><br> Will load both the \"assets/bin/tileset1_chars.bin\" and the \"assets/bin/tileset1_ncm.s\" files. NOTE: MUST be called before the Layer_InitScreen"
        },
        {
            "trigger": "Asset_ImportCharsetPalette",
            "annotation": "name",
            "contents": "Asset_ImportCharsetPalette(${1:name})",
            "kind": "snippet",
            "details": "Data generation macro that imports the full 256 color palette for the given charset name. The charset must be imported already otherwise this will fail."
        },
        {
            "trigger": "Asset_ImportSpriteset",
            "annotation": "name,charpath,address",
            "contents": "Asset_ImportSpriteset(${1:name}, ${2:charpath}, ${3:address})",
            "kind": "snippet",
            "details": "Helper function to preload the sprites _chars file generated by png65 into a given address and load the _meta file <br> S65 provides space for up to 16 sprite set imports at any one time<br> When loading using these imports you only need the first part of the path and file name. eg<br><br> Asset_ImportSpriteset(\"player\",\"assets/bin/sprites1\", $8000)<br><br> Will load both the \"assets/bin/sprites1_chars.bin\" and the \"assets/bin/sprites1_meta.s\" files. NCM or FCM is determined from the metafile<br><br> NOTE: MUST be called before the Layer_InitScreen"
        },
        {
            "trigger": "Asset_ImportSpritesetPalette",
            "annotation": "name",
            "contents": "Asset_ImportSpritesetPalette(${1:name})",
            "kind": "snippet",
            "details": "Data generation macro that imports the full 256 color palette for the given spriteset name. The spriteset must be imported already otherwise this will fail."
        },
        {
            "trigger": "Asset_GetCharset",
            "annotation": "name",
            "contents": "Asset_GetCharset(${1:name})",
            "kind": "snippet",
            "details": "This method returns the charset object containing all the vars needed to perform many operations.<br><br>  id - The numerical id of the charset assigned by Asset_ImportCharset name - The name of the spriteset<br> address - The start address for the spriteset char data <br> colorAddress - The start address for the colro table if present<br> palette - A {List} of bytes containign the palette data <br> colors - A {List} of bytes containign the ncm color mapping data <br>"
        },
        {
            "trigger": "Asset_GetSpriteset",
            "annotation": "name",
            "contents": "Asset_GetSpriteset(${1:name})",
            "kind": "snippet",
            "details": "Sprite sets are assigned numerical values from 0 to 15 in order as they are imported. This method returns the spriteset object containing all the vars needed to perform many operations, .id is used whenever referencing a spriteset in commands e.g. <a href=\"#Sprite_SetSpriteMeta\">Sprite_SetSpriteMeta</a><br><br>  id - The numerical id of the spriteset assigned by Asset_ImportSpriteset name - The name of the spriteset<br> address - The start address for the spriteset char data <br> metaAddress - The start address for the spriteset metadata <br> meta - A {List} of bytes containing the metadata<br> palette - A {List} of bytes containign the palette data <br>"
        },
        {
            "trigger": "Asset_Charset",
            "annotation": "The object returned by GetCharset",
            "kind": "snippet",
            "details": "The object returned by GetCharset"
        },
        {
            "trigger": "Asset_Spriteset",
            "annotation": "The object returned by GetSpriteset",
            "kind": "snippet",
            "details": "The object returned by GetSpriteset"
        },
        {
            "trigger": "Asset_Asset_SpriteListMetaTable",
            "annotation": "Pointer to the lookup table for the spritesets meta data tables",
            "kind": "snippet",
            "details": "Pointer to the lookup table for the spritesets meta data tables"
        },
        {
            "trigger": "DMA_CopyJob",
            "annotation": "source:destination:length:chain:Destination",
            "contents": "DMA_CopyJob ${1:source} : ${2:destination} : ${3:length} : ${4:chain} : ${5:Destination}",
            "kind": "snippet",
            "details": "Data generator that copys a defined number of bytes from one location in memory to another using the DMagic chip @ 20mb/s <br>This is NOT executable code, only data and should be used as such<br><br>"
        },
        {
            "trigger": "DMA_DisableTransparency",
            "annotation": "",
            "contents": "DMA_DisableTransparency ",
            "kind": "snippet",
            "details": "Data generator that disables the transparent byte masking. This is the default state. <br>This is NOT executable code, only data and should be used as such<br><br>"
        },
        {
            "trigger": "DMA_EnableTransparency",
            "annotation": "transparentByte",
            "contents": "DMA_EnableTransparency ${1:transparentByte}",
            "kind": "snippet",
            "details": "Data generator that enables transparent byte masking. This will ignore any source bytes that match the given byte and leave the destination byte untouched. <br>This is NOT executable code, only data and should be used as such<br><br>"
        },
        {
            "trigger": "DMA_Execute",
            "annotation": "address",
            "contents": "DMA_Execute ${1:address}",
            "kind": "snippet",
            "details": "Executes the DMagic job at the given address."
        },
        {
            "trigger": "DMA_FillJob",
            "annotation": "sourceByte:destination:length:chain",
            "contents": "DMA_FillJob ${1:sourceByte} : ${2:destination} : ${3:length} : ${4:chain}",
            "kind": "snippet",
            "details": "Data generator that fills a defined number of bytes from one location in memory to another using the DMagic chip @ 40mb/s <br>This is NOT executable code, only data and should be used as such<br><br>"
        },
        {
            "trigger": "DMA_Header",
            "annotation": "sourceBank:destBank",
            "contents": "DMA_Header ${1:sourceBank} : ${2:destBank}",
            "kind": "snippet",
            "details": "Data generator that sets the DMagic header bytes defining the source and destination banks.<br>This is NOT executable code, only data and should be used as such<br><br> Note: The bank number of a memory adress is its 5th and 6th nybble. e.g. $ff80000 is bank number $ff"
        },
        {
            "trigger": "DMA_Step",
            "annotation": "sourceStep:destStep",
            "contents": "DMA_Step ${1:sourceStep} : ${2:destStep}",
            "kind": "snippet",
            "details": "Data generator that sets the source and/or destination stepping values. The DMA will use a fixed point step for each increment on the source and destination by default they are both set to the fixed point 8:8 value $0100 (or 1.0 in decimal) <br>This is NOT executable code, only data and should be used as such<br><br>"
        },
        {
            "trigger": "DMA_F018_DMA_11_byte_format",
            "annotation": "Offsets into the DMagic job for the <a target=\"_blank\" href=\"#https://files.mega65.org/manuals-upload/mega65-chipset-reference.pdf#F018%20DMA%20Job%20List%20Format\">F018 11 byte data format</a>.",
            "kind": "snippet",
            "details": "Offsets into the DMagic job for the <a target=\"_blank\" href=\"#https://files.mega65.org/manuals-upload/mega65-chipset-reference.pdf#F018%20DMA%20Job%20List%20Format\">F018 11 byte data format</a>."
        },
        {
            "trigger": "Layer_AddText",
            "annotation": "xpos:ypos:textPtr:color",
            "contents": "Layer_AddText ${1:xpos} : ${2:ypos} : ${3:textPtr} : ${4:color}",
            "kind": "snippet",
            "details": "Writes a string of bytes to the currently active layer at the provide co-ordinates. Optionally allows the use of color, setting Color RAM Byte 1 all bits (so includes bit4-blink, bit5-reverse, bit6-bold and bit7-underline), this will only work on non NCM layers with char indices less than $100 <br> This is a conveinience function it is better to use Layer_WriteToScreen as it is more efficient<br><br> Note: As layer screen rows are interlaced in memory, its important to not let the string extend off the right edge of the layer as it can break the RRB on other layers. There is an upper limit string length of 128"
        },
        {
            "trigger": "Layer_AdvanceScreenPointers",
            "annotation": "Optional",
            "contents": "Layer_AdvanceScreenPointers ${1:Optional}",
            "kind": "snippet",
            "details": "Advances the S65 Basepage dword values for <a href=\"#Global_ColorRamPointer\">ColorRamPointer<a> and <a href=\"#Global_ScreenRamPointer\">ScreenRamPointer<a> by the given byte offset.<br><br>  Note: This method assumes you are already in the S65 base page, this is true after a <a href=\"#Layer_Get\">Layer_Get</a> command, be careful not to use this command if base page is not set, otherwise it will likely write to unintended locations"
        },
        {
            "trigger": "Layer_ClearAllLayers",
            "annotation": "clearChar",
            "contents": "Layer_ClearAllLayers ${1:clearChar}",
            "kind": "snippet",
            "details": "Fills the screen RAM area for ALL layers with a given 16bit value. Note this will overwrite any RRB GotoX markers also"
        },
        {
            "trigger": "Layer_ClearLayer",
            "annotation": "clearChar:clearColor",
            "contents": "Layer_ClearLayer ${1:clearChar} : ${2:clearColor}",
            "kind": "snippet",
            "details": "Fills the screen RAM area for the currently selected layer with a given 16bit value."
        },
        {
            "trigger": "Layer_Get",
            "annotation": "layerNum",
            "contents": "Layer_Get ${1:layerNum}",
            "kind": "snippet",
            "details": "This method sets the currently active layer for all Layer commands.<br><br> Note: This method will also call <a href=\"#S65_SetBasePage\">S65_SetBasePage</a> which is required for the Layer functions"
        },
        {
            "trigger": "Layer_GetGotoX",
            "annotation": "",
            "contents": "Layer_GetGotoX ",
            "kind": "snippet",
            "details": "Returns the gotox value for the current selected layer into <a href=\"#Global_ReturnValue\">S65_ReturnValue</a>"
        },
        {
            "trigger": "Layer_SetGotoX",
            "annotation": "gotox",
            "contents": "Layer_SetGotoX ${1:gotox}",
            "kind": "snippet",
            "details": "Sets the gotox value for the current selected layer so that it is rendered in a <a href=\"#Layer_Update\">Layer_Update</a> with a new shifted X position<br>"
        },
        {
            "trigger": "Layer_SetScreenPointersXY",
            "annotation": "xpos:ypos",
            "contents": "Layer_SetScreenPointersXY ${1:xpos} : ${2:ypos}",
            "kind": "snippet",
            "details": "Sets the basepage to point to the S65 base page area and then sets screen and color ram pointers <a href=\"#Global_ScreenRamPointer\">ScreenRamPointer<a> and <a href=\"#Global_ColorRamPointer\">ColorRamPointer<a> to point to the given layers x and y co-ordinate"
        },
        {
            "trigger": "Layer_Update",
            "annotation": "",
            "contents": "Layer_Update ",
            "kind": "snippet",
            "details": "Updates ALL the layers. This is basically the render method, it sets all the GOTOX markers for the various layers and calls the Sprite_Update method<br><br> Note: this is an expensive operation in both memory and cpu, it should be called once only per frame and put it in a subroutine if you need to call it from more than one place"
        },
        {
            "trigger": "Layer_WriteToScreen",
            "annotation": "screenSource:colorSource:size",
            "contents": "Layer_WriteToScreen ${1:screenSource} : ${2:colorSource} : ${3:size}",
            "kind": "snippet",
            "details": "Copys up to 256 bytes from the source addresses to the locations pointed at by <a href=\"#Global_ScreenRamPointer\">ScreenRamPointer<a> and optionally <a href=\"#Global_ColorRamPointer\">ColorRamPointer<a>. Does NOT change the contents of the screen and color ram pointers.<br> If immediate values are used for source then this byte is written directly<br><br> Note: This method assumes you are already in the S65 base page, this is true after a <a href=\"#Layer_Get\">Layer_Get</a> command, be careful not to use this command if base page is not set, otherwise it will likely write to unintended locations<br> If ABSY mode is used for either source then the y register is added to the address before writing. Additionally upon completion the Y register will be incremented by the amount of bytes written<br><br> Note: Writing past the end of your layers right edge can cause RRB and memory issues please use <a href=\"#Layer_AdvanceScreenPointers\">Layer_AdvanceScreenPointers<a> to move the pointers safely to the next row"
        },
        {
            "trigger": "Layer_DefineRRBSpriteLayer",
            "annotation": "charsPerLine,maxSprites",
            "contents": "Layer_DefineRRBSpriteLayer(${1:charsPerLine}, ${2:maxSprites})",
            "kind": "snippet",
            "details": "Defines a new RRB Sprite layer in Screen RAM. RRB Sprite layers are always NCM mode (16x8px chars). IO for this layer is assigned to the Layer IO dynamic memory area<br> Note that chars per line is NOT the max sprites per line as a sprite can be any multiple of 16 chars wide<br><br>   RRB Sprite space is a buffer limited by a set amount of chars per line. During an update each new Sprite uses a GOTOX marker and however many RRB chars wide it is. So, for example, a 32x32 RRB sprite is 2 chars wide + a GOTOX marker so will take 3 chars of space.<br><br> Note: There is a RRB Sprite hard limit of 256 per RRB Sprite layer.  The majority of the memory and cpu time consumed by the RRB Sprite system is a result of the number of maxSprites. Reducing this number will have the best impact on SpriteIO area memory usage as each sprite slot (regardless if its enabled or not in <a href=\"#Sprite_IOflags\">Sprite_IOflags</a>will use at least 10 bytes each. And every sprite that IS enabled will use some cpu time to update."
        },
        {
            "trigger": "Layer_DefineResolution",
            "annotation": "charWidth,charHeight,stretchWide",
            "contents": "Layer_DefineResolution(${1:charWidth}, ${2:charHeight}, ${3:stretchWide})",
            "kind": "snippet",
            "details": "Defines the screen resolution in 8x8 charachters (regardless if NCM is being used) and if it should be stretched horizontally to fit the width of the display. <a href=\"##Layer_InitScreen\">Layer_InitScreen</a> will configure the borders and TEXTXPOS and TEXTYPOS to center the screen on the display.<br><br>  NOTE:<br> - charHeight above 32 will use V400 mode and disable any RRB double buffering and double rate RRB<br> - charWidth above 42 will use H640 mode<br>"
        },
        {
            "trigger": "Layer_DefineScreenLayer",
            "annotation": "charWidth,offsetX,ncm",
            "contents": "Layer_DefineScreenLayer(${1:charWidth}, ${2:offsetX}, ${3:ncm})",
            "kind": "snippet",
            "details": "Defines a new screen layer in Screen RAM optionally shifting its RRB GOTOX offset.<br> Note: the maximum charWidth for a layer is 126"
        },
        {
            "trigger": "Layer_InitScreen",
            "annotation": "screenBaseAddress",
            "contents": "Layer_InitScreen(${1:screenBaseAddress})",
            "kind": "snippet",
            "details": "Initialises the MEGA65 and VIC-IV and parses the Layer definitions into a Screen RAM layout"
        },
        {
            "trigger": "Layer_GetColorAddress",
            "annotation": "layerNumber,xpos,ypos",
            "contents": "Layer_GetColorAddress(${1:layerNumber}, ${2:xpos}, ${3:ypos})",
            "kind": "snippet",
            "details": "Returns the address of the color RAM at the given position on this screen layer"
        },
        {
            "trigger": "Layer_GetIO",
            "annotation": "layerNumber,register",
            "contents": "Layer_GetIO(${1:layerNumber}, ${2:register})",
            "kind": "snippet",
            "details": "Returns the base address for the given layer & register.<br> See <a href='#Layer_Vars'>Layer_IO<a> for register list"
        },
        {
            "trigger": "Layer_GetLayerCount",
            "annotation": "",
            "contents": "Layer_GetLayerCount()",
            "kind": "snippet",
            "details": "Returns the current number of layers, useful for assigning to constants to name each layer for use in your code."
        },
        {
            "trigger": "Layer_GetScreenAddress",
            "annotation": "layerNumber,xpos,ypos",
            "contents": "Layer_GetScreenAddress(${1:layerNumber}, ${2:xpos}, ${3:ypos})",
            "kind": "snippet",
            "details": "Returns the address of the char at the given position on this screen layer"
        },
        {
            "trigger": "Layer_GotoXColorPositions",
            "annotation": "Table of GOTOX Attribute in color ram for each layer",
            "kind": "snippet",
            "details": "Table of GOTOX Attribute in color ram for each layer"
        },
        {
            "trigger": "Layer_GotoXPositions",
            "annotation": "Table of current GOTOX positions for all the layers",
            "kind": "snippet",
            "details": "Table of current GOTOX positions for all the layers"
        },
        {
            "trigger": "Layer_LayerWidth",
            "annotation": "Table of start address offsets for each layer",
            "kind": "snippet",
            "details": "Table of start address offsets for each layer"
        },
        {
            "trigger": "Layer_LogicalWidth",
            "annotation": "Contains the current Screen Row Logical Width in bytes",
            "kind": "snippet",
            "details": "Contains the current Screen Row Logical Width in bytes"
        },
        {
            "trigger": "Layer_AddrOffsets",
            "annotation": "Pointer to Table of start address offsets for each layer",
            "kind": "snippet",
            "details": "Pointer to Table of start address offsets for each layer"
        },
        {
            "trigger": "Layer_DMAClear",
            "annotation": "Pointer to a dma subroutine that clears the screen ram layer, A=layer, X=charLo, Y=charHi",
            "kind": "snippet",
            "details": "Pointer to a dma subroutine that clears the screen ram layer, A=layer, X=charLo, Y=charHi"
        },
        {
            "trigger": "Layer_DMAClearColor",
            "annotation": "Pointer to a dma subroutine that clears the color ram layer, A=layer, X=color",
            "kind": "snippet",
            "details": "Pointer to a dma subroutine that clears the color ram layer, A=layer, X=color"
        },
        {
            "trigger": "Layer_DMAClearColorRRB",
            "annotation": "Pointer to a dma subroutine that clears the color ram layer for RRB sprites, A=layer",
            "kind": "snippet",
            "details": "Pointer to a dma subroutine that clears the color ram layer for RRB sprites, A=layer"
        },
        {
            "trigger": "Layer_DynamicDataTable",
            "annotation": "A pointer to the table containing the address of each layers dynamic data, this memory is initialised on a <a href='#Layer_InitScreen'>Layer_InitScreen</a> it's size is dependant on the screen layer structure, RRB sprite layers use the most memory",
            "kind": "snippet",
            "details": "A pointer to the table containing the address of each layers dynamic data, this memory is initialised on a <a href='#Layer_InitScreen'>Layer_InitScreen</a> it's size is dependant on the screen layer structure, RRB sprite layers use the most memory"
        },
        {
            "trigger": "Layer_IOgotoX",
            "annotation": "The IO register index for this layers GOTOX value. Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function.",
            "kind": "snippet",
            "details": "The IO register index for this layers GOTOX value. Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function."
        },
        {
            "trigger": "Layer_IOmaxCharsRRB",
            "annotation": "RRB SPRITE LAYER ONLY. The IO register index for this layers maximum chars per line value. <br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function.",
            "kind": "snippet",
            "details": "RRB SPRITE LAYER ONLY. The IO register index for this layers maximum chars per line value. <br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function."
        },
        {
            "trigger": "Layer_IOmaxSpritesRRB",
            "annotation": "RRB SPRITE LAYER ONLY. The IO register index for this layers maximum sprites value.<br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function.",
            "kind": "snippet",
            "details": "RRB SPRITE LAYER ONLY. The IO register index for this layers maximum sprites value.<br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function."
        },
        {
            "trigger": "Layer_IOrowCountTableRRB",
            "annotation": "RRB SPRITE LAYER ONLY. The IO register index for this layers RRB sprite rowCharCount table, used internally by the RRB sprite system.<br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function.",
            "kind": "snippet",
            "details": "RRB SPRITE LAYER ONLY. The IO register index for this layers RRB sprite rowCharCount table, used internally by the RRB sprite system.<br> Retrieve the absolute address by passing it to the <a href='#Layer_GetIO'>Layer_GetIO</a> function."
        },
        {
            "trigger": "Layer_IsRRBSprite",
            "annotation": "Pointer to the table of flags indicating if layers are RRB sprite layer",
            "kind": "snippet",
            "details": "Pointer to the table of flags indicating if layers are RRB sprite layer"
        },
        {
            "trigger": "Layer_RowAddressBaseLSB",
            "annotation": "Pointer to the table of LSB values for the address of the start of each screen row directly",
            "kind": "snippet",
            "details": "Pointer to the table of LSB values for the address of the start of each screen row directly"
        },
        {
            "trigger": "Layer_RowAddressBaseMSB",
            "annotation": "Pointer to the table of MSB values for the address of the start of each screen row directly",
            "kind": "snippet",
            "details": "Pointer to the table of MSB values for the address of the start of each screen row directly"
        },
        {
            "trigger": "Layer_RowAddressLSB",
            "annotation": "Pointer to the table of LSB values for the address of the start of each screen row directly after the first GOTOX",
            "kind": "snippet",
            "details": "Pointer to the table of LSB values for the address of the start of each screen row directly after the first GOTOX"
        },
        {
            "trigger": "Layer_RowAddressMSB",
            "annotation": "Pointer to the table of MSB values for the address of the start of each screen row directly after the first GOTOX",
            "kind": "snippet",
            "details": "Pointer to the table of MSB values for the address of the start of each screen row directly after the first GOTOX"
        },
        {
            "trigger": "Layer_SpriteIOAddrLSB",
            "annotation": "Pointer to the table of LSB values for the address of the start of the layers sprite IO area",
            "kind": "snippet",
            "details": "Pointer to the table of LSB values for the address of the start of the layers sprite IO area"
        },
        {
            "trigger": "Layer_SpriteIOAddrMSB",
            "annotation": "Pointer to the table of MSB values for the address of the start of the layers sprite IO area",
            "kind": "snippet",
            "details": "Pointer to the table of MSB values for the address of the start of the layers sprite IO area"
        },
        {
            "trigger": "Palette_Assign",
            "annotation": "palleteChar:paletteHWSprite:paletteRRBSprite",
            "contents": "Palette_Assign ${1:palleteChar} : ${2:paletteHWSprite} : ${3:paletteRRBSprite}",
            "kind": "snippet",
            "details": "Assigns palettes to the MEGA65 palette banks."
        },
        {
            "trigger": "Palette_LoadFromMem",
            "annotation": "addr:size",
            "contents": "Palette_LoadFromMem ${1:addr} : ${2:size}",
            "kind": "snippet",
            "details": "Copys palette data from a given address into the currently active palette."
        },
        {
            "trigger": "Palette_LoadFromSD",
            "annotation": "addr",
            "contents": "Palette_LoadFromSD ${1:addr}",
            "kind": "snippet",
            "details": "Loads a full 256 color palette from SD card into the currently active palette"
        },
        {
            "trigger": "Palette_Set",
            "annotation": "paletteNum",
            "contents": "Palette_Set ${1:paletteNum}",
            "kind": "snippet",
            "details": "Sets the currently active palette in IO memory."
        },
        {
            "trigger": "Palette_MEGA65_Palette",
            "annotation": "The MEGA65 has up to 4 palettes that can be assigned to the various graphic types Sprite and Character. At any one time one of the palettes will be banked into IO memory at $d100-$d3ff.  Note: While the palette format is RGB788 the nybbles of each byte are switched e.g. $F0 becomes $0F, to maintain compatibility with the C65",
            "kind": "snippet",
            "details": "The MEGA65 has up to 4 palettes that can be assigned to the various graphic types Sprite and Character. At any one time one of the palettes will be banked into IO memory at $d100-$d3ff.  Note: While the palette format is RGB788 the nybbles of each byte are switched e.g. $F0 becomes $0F, to maintain compatibility with the C65"
        },
        {
            "trigger": "Palette_0",
            "annotation": "MEGA65 palette 0",
            "kind": "snippet",
            "details": "MEGA65 palette 0"
        },
        {
            "trigger": "Palette_1",
            "annotation": "MEGA65 palette 1",
            "kind": "snippet",
            "details": "MEGA65 palette 1"
        },
        {
            "trigger": "Palette_2",
            "annotation": "MEGA65 palette 2",
            "kind": "snippet",
            "details": "MEGA65 palette 2"
        },
        {
            "trigger": "Palette_3",
            "annotation": "MEGA65 palette 3",
            "kind": "snippet",
            "details": "MEGA65 palette 3"
        },
        {
            "trigger": "SDCard_LoadToAtticRam",
            "annotation": "addr:filePtr",
            "contents": "SDCard_LoadToAtticRam ${1:addr} : ${2:filePtr}",
            "kind": "snippet",
            "details": "Loads a file from the SDCard into attic RAM"
        },
        {
            "trigger": "SDCard_LoadToChipRam",
            "annotation": "addr:filePtr",
            "contents": "SDCard_LoadToChipRam ${1:addr} : ${2:filePtr}",
            "kind": "snippet",
            "details": "Loads a file from the SDCard into chip RAM"
        },
        {
            "trigger": "Sprite_Get",
            "annotation": "layerNum:sprNum",
            "contents": "Sprite_Get ${1:layerNum} : ${2:sprNum}",
            "kind": "snippet",
            "details": "This method is a prerequisite for getting or setting any sprites IO registers it sets the \"current active\" sprite used by the Sprite Get and Set methods by storing the pointer to that sprites IO area in <a href=\"#S65_LastSpriteIOPointer\">S65_LastSpriteIOPointer</a><br><br> Note: This method will also call <a href=\"#S65_SetBasePage\">S65_SetBasePage</a> which is required for the subsequent Sprite functions"
        },
        {
            "trigger": "Sprite_GetColor",
            "annotation": "",
            "contents": "Sprite_GetColor ",
            "kind": "snippet",
            "details": "Returns the color of the currently selected sprite in <a href=\"#Global_ReturnValue\">S65_ReturnValue</a> and the accumulator Lo byte is color<br> Note that colors are in the upper nybble in NCM mode, so palette slice $02 is represented as $20"
        },
        {
            "trigger": "Sprite_GetDimensions",
            "annotation": "",
            "contents": "Sprite_GetDimensions ",
            "kind": "snippet",
            "details": "Returns the dimensions of the currently selected sprite into <a href=\"#Global_ReturnValue\">S65_ReturnValue</a><br> Lo byte is width, Hi byte is height"
        },
        {
            "trigger": "Sprite_GetEnabled",
            "annotation": "",
            "contents": "Sprite_GetEnabled ",
            "kind": "snippet",
            "details": "Returns the enabled state of the current selected sprite into <a href=\"#Global_ReturnValue\">S65_ReturnValue</a>"
        },
        {
            "trigger": "Sprite_GetFlags",
            "annotation": "",
            "contents": "Sprite_GetFlags ",
            "kind": "snippet",
            "details": "Returns the flags of the current selected sprite into <a href=\"#Global_ReturnValue\">S65_ReturnValue</a>"
        },
        {
            "trigger": "Sprite_GetPointer",
            "annotation": "",
            "contents": "Sprite_GetPointer ",
            "kind": "snippet",
            "details": "Returns the current pointer of the currently selected sprite into <a href=\"#Global_ReturnValue\">S65_ReturnValue</a>"
        },
        {
            "trigger": "Sprite_GetPositionX",
            "annotation": "",
            "contents": "Sprite_GetPositionX ",
            "kind": "snippet",
            "details": "Returns the X position of the current selected sprite into <a href=\"#Global_ReturnValue\">S65_ReturnValue</a>"
        },
        {
            "trigger": "Sprite_GetPositionY",
            "annotation": "",
            "contents": "Sprite_GetPositionY ",
            "kind": "snippet",
            "details": "Returns the Y position of the current selected sprite into <a href=\"#Global_ReturnValue\">S65_ReturnValue</a>"
        },
        {
            "trigger": "Sprite_ResetFlags",
            "annotation": "flags",
            "contents": "Sprite_ResetFlags ${1:flags}",
            "kind": "snippet",
            "details": "Resets one or more of the currently selected sprites flags. You can use the <a href=\"#Sprite_IOflagEnabled\">flag constants</a> provided by S65 to abstract the values. The other flags are left untouched"
        },
        {
            "trigger": "Sprite_SetColor",
            "annotation": "color",
            "contents": "Sprite_SetColor ${1:color}",
            "kind": "snippet",
            "details": "Sets the currently selected sprites color. Note that colors are in the upper nybble in NCM mode, so palette slice $02 is represented as $20"
        },
        {
            "trigger": "Sprite_SetDimensions",
            "annotation": "width:height",
            "contents": "Sprite_SetDimensions ${1:width} : ${2:height}",
            "kind": "snippet",
            "details": "Sets the currently selected sprites width and height. There is a hard limit of 255 chars to make up any one sprite therefore width * height MUST be less than 256"
        },
        {
            "trigger": "Sprite_SetEnabled",
            "annotation": "enabled",
            "contents": "Sprite_SetEnabled ${1:enabled}",
            "kind": "snippet",
            "details": "Enables or disables the current selected sprite so that it is rendered in a <a href=\"#Layer_Update\">Layer_Update</a><br> Sets <a href=\"#Global_LastSpriteIOPointer\">S65_LastSpriteIOPointer</a><br><br>"
        },
        {
            "trigger": "Sprite_SetFlags",
            "annotation": "flags",
            "contents": "Sprite_SetFlags ${1:flags}",
            "kind": "snippet",
            "details": "Sets one or more of the currently selected sprites flags. You can use the <a href=\"#Sprite_IOflagEnabled\">flag constants</a> provided by S65 to abstract the values. The other flags are left untouched"
        },
        {
            "trigger": "Sprite_SetPointer",
            "annotation": "pointer",
            "contents": "Sprite_SetPointer ${1:pointer}",
            "kind": "snippet",
            "details": "Sets the current selected sprite pointer. If pointer is passed as a register it sets ONLY the LSB, MSB sets to 0. If ABS mode is used then two bytes are read from that address and used to set the value"
        },
        {
            "trigger": "Sprite_SetPositionX",
            "annotation": "xpos",
            "contents": "Sprite_SetPositionX ${1:xpos}",
            "kind": "snippet",
            "details": "Sets the current selected sprite X position. If position is passed as a register it sets ONLY the LSB, MSB sets to 0. If ABS mode is used then two bytes are read from that address and used to set the value"
        },
        {
            "trigger": "Sprite_SetPositionY",
            "annotation": "ypos",
            "contents": "Sprite_SetPositionY ${1:ypos}",
            "kind": "snippet",
            "details": "Sets the current selected sprite Y position. If position is passed as a register it sets ONLY the LSB, MSB sets to 0. If ABS mode is used then two bytes are read from that address and used to set the value"
        },
        {
            "trigger": "Sprite_SetSpriteMeta",
            "annotation": "spritesId:spriteNum",
            "contents": "Sprite_SetSpriteMeta ${1:spritesId} : ${2:spriteNum}",
            "kind": "snippet",
            "details": "Enables the currently selected sprite and popualtes its IO registers with the meta data for the given spriteset index. Affects:<br> - IOflags (Enabled, NCM)<br> - IOwidth<br> - IOheight<br> - IOptr<br> - IOcolor<br>"
        },
        {
            "trigger": "Sprite_Update",
            "annotation": "",
            "contents": "Sprite_Update ",
            "kind": "snippet",
            "details": "Called internally by <a href=\"#Layer_Update\">Layer_Update</a><br>"
        },
        {
            "trigger": "Sprite_GenerateLayerData",
            "annotation": "",
            "contents": "Sprite_GenerateLayerData()",
            "kind": "snippet",
            "details": "Internally used macro for assigning sprite IO area during a <a href=\"#Layer_InitScreen\">Layer_InitScreen</a>"
        },
        {
            "trigger": "Sprite_GenerateMetaData",
            "annotation": "",
            "contents": "Sprite_GenerateMetaData()",
            "kind": "snippet",
            "details": "Internally used to generate the runtime lookup tables for sprite meta data"
        },
        {
            "trigger": "Sprite_GetIO",
            "annotation": "layerNumber,spriteNumber,register",
            "contents": "Sprite_GetIO(${1:layerNumber}, ${2:spriteNumber}, ${3:register})",
            "kind": "snippet",
            "details": "Returns the base address for the given layer & IO register.<br> See <a href='#Sprite_Vars'>Sprite_IO<a> for register list"
        },
        {
            "trigger": "Sprite_MetaData",
            "annotation": "This is a byte array used by the engine when Asset_ImportSpriteset and Asset_ImportSpritesetMeta is used to store all the meta data for the sprites such as mappings from sprite to character numbers, colors etc.",
            "kind": "snippet",
            "details": "This is a byte array used by the engine when Asset_ImportSpriteset and Asset_ImportSpritesetMeta is used to store all the meta data for the sprites such as mappings from sprite to character numbers, colors etc."
        },
        {
            "trigger": "Sprite_IOcolor",
            "annotation": "The color to apply to all the chars in this sprite.",
            "kind": "snippet",
            "details": "The color to apply to all the chars in this sprite."
        },
        {
            "trigger": "Sprite_IOflagEnabled",
            "annotation": "The value to set the enabled bit in <a href=\"#Sprite_IOflags\">Sprite_IOflags</a>",
            "kind": "snippet",
            "details": "The value to set the enabled bit in <a href=\"#Sprite_IOflags\">Sprite_IOflags</a>"
        },
        {
            "trigger": "Sprite_IOflagFlipH",
            "annotation": "The value to set the flip H bit in <a href=\"#Sprite_IOflags\">Sprite_IOflags</a>",
            "kind": "snippet",
            "details": "The value to set the flip H bit in <a href=\"#Sprite_IOflags\">Sprite_IOflags</a>"
        },
        {
            "trigger": "Sprite_IOflagFlipV",
            "annotation": "The value to set the flip V bit in <a href=\"#Sprite_IOflags\">Sprite_IOflags</a><br><br> NOTE: Currently due to HW limitations (missing ROWMASK functionality) this flag will cause rendering issues and should NOT be used",
            "kind": "snippet",
            "details": "The value to set the flip V bit in <a href=\"#Sprite_IOflags\">Sprite_IOflags</a><br><br> NOTE: Currently due to HW limitations (missing ROWMASK functionality) this flag will cause rendering issues and should NOT be used"
        },
        {
            "trigger": "Sprite_IOflagNCM",
            "annotation": "Turns on NCM for this sprite<br><br> NOTE: It is best to use NCM where possible as it takes half the processing time per visible sprite on a Layer_Update, less chars on a line, and less memory for the image data at the cost of dropping to 16 colors",
            "kind": "snippet",
            "details": "Turns on NCM for this sprite<br><br> NOTE: It is best to use NCM where possible as it takes half the processing time per visible sprite on a Layer_Update, less chars on a line, and less memory for the image data at the cost of dropping to 16 colors"
        },
        {
            "trigger": "Sprite_IOflags",
            "annotation": "Flags for the state of this sprite  bit 7 = Flip V (Not yet implemented) bit 6 = Flip H bit 5 = Enabled",
            "kind": "snippet",
            "details": "Flags for the state of this sprite  bit 7 = Flip V (Not yet implemented) bit 6 = Flip H bit 5 = Enabled"
        },
        {
            "trigger": "Sprite_IOflipHoffset",
            "annotation": "This registers is set internally on creation of a sprite and should NOT be manually changed",
            "kind": "snippet",
            "details": "This registers is set internally on creation of a sprite and should NOT be manually changed"
        },
        {
            "trigger": "Sprite_IOflipVoffset",
            "annotation": "This registers is set internally on creation of a sprite and should NOT be manually changed",
            "kind": "snippet",
            "details": "This registers is set internally on creation of a sprite and should NOT be manually changed"
        },
        {
            "trigger": "Sprite_IOheight",
            "annotation": "The height in chars for this sprite, sprites will automatically advance through the char set as they are drawn in pieces, top to bottom, left to right.",
            "kind": "snippet",
            "details": "The height in chars for this sprite, sprites will automatically advance through the char set as they are drawn in pieces, top to bottom, left to right."
        },
        {
            "trigger": "Sprite_IOptr",
            "annotation": "The IO register offset for looking up the sprite pointer location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address.",
            "kind": "snippet",
            "details": "The IO register offset for looking up the sprite pointer location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address."
        },
        {
            "trigger": "Sprite_IOwidth",
            "annotation": "The width in chars for this sprite, sprites will automatically advance through the char set as they are drawn in pieces, top to bottom, left to right.",
            "kind": "snippet",
            "details": "The width in chars for this sprite, sprites will automatically advance through the char set as they are drawn in pieces, top to bottom, left to right."
        },
        {
            "trigger": "Sprite_IOx",
            "annotation": "The IO register offset for looking up the a sprites x position location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address.",
            "kind": "snippet",
            "details": "The IO register offset for looking up the a sprites x position location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address."
        },
        {
            "trigger": "Sprite_IOy",
            "annotation": "The IO register offset for looking up the a sprites y position location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address.",
            "kind": "snippet",
            "details": "The IO register offset for looking up the a sprites y position location in memory. Pass this to the <a href='#Sprite_GetIO'>Sprite_GetIO</a> function, to retrieve the address."
        },
        {
            "trigger": "Sprite_SpriteIOLength",
            "annotation": "The size in bytes of the IO registers for a single sprite",
            "kind": "snippet",
            "details": "The size in bytes of the IO registers for a single sprite"
        },
        {
            "trigger": "System_GetRandom16",
            "annotation": "",
            "contents": "System_GetRandom16 ",
            "kind": "snippet",
            "details": "Returns a random 16 bit number in <a href=\"#Global_ReturnValue\">S65_ReturnValue</a>"
        },
        {
            "trigger": "System_GetRandom8",
            "annotation": "",
            "contents": "System_GetRandom8 ",
            "kind": "snippet",
            "details": "Returns a random 8 bit number in <a href=\"#Global_ReturnValue\">S65_ReturnValue</a> and the accumulator"
        },
        {
            "trigger": "System_BasicUpstart65",
            "annotation": "addr",
            "contents": "System_BasicUpstart65(${1:addr})",
            "kind": "snippet",
            "details": "Creates the <a href='#System_BasicUpstart65_Format'>Basic Upstart</a> for the MEGA65 at location $2001 pointing to the given SYS entry address"
        },
        {
            "trigger": "System_BorderDebug",
            "annotation": "color",
            "contents": "System_BorderDebug(${1:color})",
            "kind": "snippet",
            "details": "If the preprocessor #define NODEBUG is not defined this will set the border color to the give value. Useful for debugging"
        },
        {
            "trigger": "System_DisableC65ROM",
            "annotation": "",
            "contents": "System_DisableC65ROM()",
            "kind": "snippet",
            "details": "Disables the C65 rom protection making it writable"
        },
        {
            "trigger": "System_Enable40Mhz",
            "annotation": "",
            "contents": "System_Enable40Mhz()",
            "kind": "snippet",
            "details": "Switches the MEGA65 45GS_02 processor to use 40.5Mhz mode"
        },
        {
            "trigger": "System_EnableFastRRB",
            "annotation": "",
            "contents": "System_EnableFastRRB()",
            "kind": "snippet",
            "details": "Enables rewrite double buffering to prevent clipping on the left side of the screen and enable 2 raster scans per line for double pixel clock in V200 mode."
        },
        {
            "trigger": "System_EnableVIC4",
            "annotation": "",
            "contents": "System_EnableVIC4()",
            "kind": "snippet",
            "details": "Switches the VIC chip in the MEGA65 into VIC4 mode."
        },
        {
            "trigger": "System_WaitForRaster",
            "annotation": "raster",
            "contents": "System_WaitForRaster(${1:raster})",
            "kind": "snippet",
            "details": "Halts execution and waits for the given raster line"
        },
        {
            "trigger": "System_BasicUpstart65_Format",
            "annotation": "",
            "kind": "snippet",
            "details": ""
        }
    ]
}